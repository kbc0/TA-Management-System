Project Path: backend

Source Tree:

```txt
backend
├── config
│   ├── auth.js
│   └── db.js
├── controllers
│   ├── authController.js
│   ├── leaveController.js
│   ├── swapController.js
│   └── taskController.js
├── docs
├── middleware
│   ├── authMiddleware.js
│   └── validationMiddleware.js
├── models
│   ├── Leave.js
│   ├── Swap.js
│   ├── Task.js
│   └── User.js
├── package.json
├── routes
│   ├── authRoutes.js
│   ├── leaveRoutes.js
│   ├── swapRoutes.js
│   └── taskRoutes.js
└── server.js

```

`backend/config/auth.js`:

```js
module.exports = {
  jwtSecret: process.env.JWT_SECRET,
  jwtExpiresIn: '5000h'
};

```

`backend/config/db.js`:

```js
// backend/config/db.js
const mysql = require('mysql2/promise');

const pool = mysql.createPool({
  host: process.env.DB_HOST,
  user: process.env.DB_USER,
  password: process.env.DB_PASSWORD,
  database: process.env.DB_NAME,
  waitForConnections: true,
  connectionLimit: 10,
  queueLimit: 0
});

module.exports = pool;

```

`backend/controllers/authController.js`:

```js
// backend/controllers/authController.js
const User = require('../models/User');
const jwt = require('jsonwebtoken');
const { jwtSecret, jwtExpiresIn } = require('../config/auth');
const nodemailer = require('nodemailer');
const crypto = require('crypto');

// Store reset tokens temporarily (In production, use a database)
const resetTokens = {};

// Set up transporter for email
let transporter;

// Check if we're in development mode
if (process.env.NODE_ENV === 'development' || !process.env.MAIL_HOST) {
  console.log('Using mock email transport for development');
  // Create a mock transporter that logs emails instead of sending them
  transporter = {
    sendMail: async (mailOptions) => {
      console.log('Mock email sent:');
      console.log('To:', mailOptions.to);
      console.log('Subject:', mailOptions.subject);
      console.log('Content:', mailOptions.html || mailOptions.text);
      return { messageId: 'mock-email-id-' + Date.now() };
    }
  };
} else {
  // Use real nodemailer transport for production
  transporter = nodemailer.createTransport({
    host: process.env.MAIL_HOST,
    port: process.env.MAIL_PORT,
    secure: false,
    auth: {
      user: process.env.MAIL_USER,
      pass: process.env.MAIL_PASS
    }
  });
}

/**
 * Validates request parameters and returns missing or invalid fields
 * @param {Object} params - The parameters to validate
 * @param {Array} required - List of required field names
 * @returns {Object} - Object containing validation results
 */
const validateParams = (params, required) => {
  const missingFields = [];
  const errors = {};
  
  // Check for missing required fields
  required.forEach(field => {
    if (!params[field] && params[field] !== 0) {
      missingFields.push(field);
    }
  });
  
  // Email format validation (if email is provided)
  if (params.email && !params.email.endsWith('@bilkent.edu.tr')) {
    errors.email = 'Must use a Bilkent email address ending with @bilkent.edu.tr';
  }
  
  // Password strength validation (if password is provided)
  if (params.password && params.password.length < 6) {
    errors.password = 'Password must be at least 6 characters long';
  }
  
  return {
    isValid: missingFields.length === 0 && Object.keys(errors).length === 0,
    missingFields,
    errors
  };
};

/**
 * Register a new user
 * @route POST /api/auth/signup
 * @param {string} bilkentId - User's Bilkent ID
 * @param {string} email - User's email (must be @bilkent.edu.tr)
 * @param {string} fullName - User's full name
 * @param {string} password - User's password (min 6 characters)
 * @param {string} [role] - User's role (defaults to 'ta')
 */
exports.signup = async (req, res) => {
  try {
    // Normalize parameters - accept both camelCase and snake_case
    const bilkentId = req.body.bilkentId || req.body.bilkent_id;
    const email = req.body.email;
    const fullName = req.body.fullName || req.body.full_name;
    const password = req.body.password;
    const role = req.body.role;

    // Validate input
    const validation = validateParams(
      { bilkentId, email, fullName, password },
      ['bilkentId', 'email', 'fullName', 'password']
    );

    if (!validation.isValid) {
      const errorResponse = {
        message: 'Validation failed',
        details: {}
      };
      
      if (validation.missingFields.length > 0) {
        errorResponse.details.missingFields = validation.missingFields;
      }
      
      if (Object.keys(validation.errors).length > 0) {
        errorResponse.details.errors = validation.errors;
      }
      
      return res.status(400).json(errorResponse);
    }

    // Check if user already exists
    const existingUser = await User.findByBilkentId(bilkentId);
    if (existingUser) {
      return res.status(409).json({ message: 'User with this Bilkent ID already exists' });
    }

    // Check if email is already in use
    const emailExists = await User.findByEmail(email);
    if (emailExists) {
      return res.status(409).json({ message: 'Email is already in use' });
    }

    // Validate role (assuming roles are predefined)
    const validRoles = ['ta', 'staff', 'department_chair', 'dean', 'admin']; // Match database enum values
    if (role && !validRoles.includes(role)) {
      return res.status(400).json({ 
        message: 'Invalid role specified',
        validRoles
      });
    }

    // Create new user
    const newUser = await User.create({
      bilkent_id: bilkentId,
      email,
      full_name: fullName,
      password, // The User model should handle password hashing
      role: role || 'ta' // Default role if not specified
    });

    // Generate JWT token
    const token = jwt.sign(
      { id: newUser.id, bilkentId: newUser.bilkent_id, role: newUser.role },
      jwtSecret,
      { expiresIn: jwtExpiresIn }
    );

    // Return user data and token
    res.status(201).json({
      message: 'User registered successfully',
      token,
      user: {
        id: newUser.id,
        bilkentId: newUser.bilkent_id,
        email: newUser.email,
        fullName: newUser.full_name,
        role: newUser.role
      }
    });
  } catch (error) {
    console.error('Signup error:', error);
    res.status(500).json({ message: 'Server error during signup', error: error.message });
  }
};

/**
 * Log in a user
 * @route POST /api/auth/login
 * @param {string} bilkentId - User's Bilkent ID
 * @param {string} password - User's password
 */
exports.login = async (req, res) => {
  try {
    // Normalize parameters - accept both camelCase and snake_case
    const bilkentId = req.body.bilkentId || req.body.bilkent_id;
    const password = req.body.password;

    // Validate input
    const validation = validateParams(
      { bilkentId, password },
      ['bilkentId', 'password']
    );

    if (!validation.isValid) {
      const errorResponse = {
        message: 'Validation failed',
        details: {}
      };
      
      if (validation.missingFields.length > 0) {
        errorResponse.details.missingFields = validation.missingFields;
      }
      
      return res.status(400).json(errorResponse);
    }

    // Find user by BilkentID
    const user = await User.findByBilkentId(bilkentId);

    // Check if user exists
    if (!user) {
      return res.status(401).json({ message: 'Invalid credentials' });
    }

    // Verify password
    const isPasswordValid = await User.verifyPassword(password, user.password);
    if (!isPasswordValid) {
      return res.status(401).json({ message: 'Invalid credentials' });
    }

    // Generate JWT token
    const token = jwt.sign(
      { id: user.id, bilkentId: user.bilkent_id, role: user.role },
      jwtSecret,
      { expiresIn: jwtExpiresIn }
    );

    // Return user data and token
    res.json({
      token,
      user: {
        id: user.id,
        bilkentId: user.bilkent_id,
        email: user.email,
        fullName: user.full_name,
        role: user.role
      }
    });
  } catch (error) {
    console.error('Login error:', error);
    res.status(500).json({ message: 'Server error during login', error: error.message });
  }
};

/**
 * Send password recovery email
 * @route POST /api/auth/recover-password
 * @param {string} bilkentId - User's Bilkent ID
 */
exports.recoverPassword = async (req, res) => {
  try {
    // Normalize parameters
    const bilkentId = req.body.bilkentId || req.body.bilkent_id;

    // Validate input
    const validation = validateParams({ bilkentId }, ['bilkentId']);
    
    if (!validation.isValid) {
      const errorResponse = {
        message: 'Validation failed',
        details: {}
      };
      
      if (validation.missingFields.length > 0) {
        errorResponse.details.missingFields = validation.missingFields;
      }
      
      return res.status(400).json(errorResponse);
    }

    // Find user by BilkentID
    const user = await User.findByBilkentId(bilkentId);

    // If user doesn't exist, still show success to prevent email enumeration
    if (!user) {
      return res.json({ message: 'If your ID exists, a password reset link has been sent to your email' });
    }

    // Generate a reset token
    const resetToken = crypto.randomBytes(20).toString('hex');
    resetTokens[bilkentId] = {
      token: resetToken,
      expiresAt: Date.now() + 3600000 // Token expires in 1 hour
    };

    // Create reset URL
    const resetUrl = `${process.env.FRONTEND_URL || 'http://localhost:3000'}/reset-password/${resetToken}?id=${bilkentId}`;

    try {
      // Send email
      await transporter.sendMail({
        to: user.email,
        subject: 'Password Reset for TA Management System',
        html: `
          <p>Hello ${user.full_name},</p>
          <p>You requested a password reset for the TA Management System.</p>
          <p>Please click the link below to reset your password:</p>
          <a href="${resetUrl}">Reset Password</a>
          <p>If you didn't request this, please ignore this email.</p>
          <p>The link will expire in 1 hour.</p>
        `
      });
      
      console.log(`Password reset email sent to ${user.email}`);
    } catch (emailError) {
      console.error('Email sending failed:', emailError);
      // Continue with the process even if email fails
      // In production, you might want to log this to a monitoring system
    }

    res.json({ message: 'If your ID exists, a password reset link has been sent to your email' });
  } catch (error) {
    console.error('Password recovery error:', error);
    res.status(500).json({ message: 'Server error during password recovery', error: error.message });
  }
};

/**
 * Reset user password
 * @route POST /api/auth/reset-password
 * @param {string} token - Reset token
 * @param {string} bilkentId - User's Bilkent ID
 * @param {string} newPassword - New password
 */
exports.resetPassword = async (req, res) => {
  try {
    // Normalize parameters
    const token = req.body.token;
    const bilkentId = req.body.bilkentId || req.body.bilkent_id;
    const newPassword = req.body.newPassword || req.body.new_password;

    // Validate input
    const validation = validateParams(
      { token, bilkentId, newPassword },
      ['token', 'bilkentId', 'newPassword']
    );
    
    if (!validation.isValid) {
      const errorResponse = {
        message: 'Validation failed',
        details: {}
      };
      
      if (validation.missingFields.length > 0) {
        errorResponse.details.missingFields = validation.missingFields;
      }
      
      if (Object.keys(validation.errors).length > 0) {
        errorResponse.details.errors = validation.errors;
      }
      
      return res.status(400).json(errorResponse);
    }

    // Check if token exists and is valid
    if (!resetTokens[bilkentId] || 
        resetTokens[bilkentId].token !== token || 
        resetTokens[bilkentId].expiresAt < Date.now()) {
      return res.status(400).json({ message: 'Invalid or expired token' });
    }

    // Update password
    const updated = await User.updatePassword(bilkentId, newPassword);
    if (!updated) {
      return res.status(404).json({ message: 'User not found' });
    }

    // Remove used token
    delete resetTokens[bilkentId];

    res.json({ message: 'Password has been reset successfully' });
  } catch (error) {
    console.error('Password reset error:', error);
    res.status(500).json({ message: 'Server error during password reset', error: error.message });
  }
};

/**
 * Log out a user (client-side implementation)
 * @route POST /api/auth/logout
 */
exports.logout = (req, res) => {
  // JWT tokens are stateless, so we can't invalidate them on the server
  // The client should remove the token from storage
  res.json({ message: 'Logged out successfully' });
};
```

`backend/controllers/leaveController.js`:

```js
// backend/controllers/leaveController.js
const Leave = require('../models/Leave');

/**
 * Get all leave requests based on user role
 * @route GET /api/leaves
 */
exports.getAllLeaves = async (req, res) => {
  try {
    const leaves = await Leave.findAll(req.user.id, req.user.role);
    res.json(leaves);
  } catch (error) {
    console.error('Error fetching leave requests:', error);
    res.status(500).json({ message: 'Server error while fetching leave requests', error: error.message });
  }
};

/**
 * Get a specific leave request by ID
 * @route GET /api/leaves/:id
 */
exports.getLeaveById = async (req, res) => {
  try {
    const leave = await Leave.findById(req.params.id);
    
    if (!leave) {
      return res.status(404).json({ message: 'Leave request not found' });
    }
    
    // Check if user has permission to view this leave request
    if (req.user.role !== 'admin' && 
        req.user.role !== 'department_chair' && 
        req.user.role !== 'staff' &&
        req.user.id !== leave.user_id) {
      return res.status(403).json({ message: 'You do not have permission to view this leave request' });
    }
    
    res.json(leave);
  } catch (error) {
    console.error('Error fetching leave request:', error);
    res.status(500).json({ message: 'Server error while fetching leave request', error: error.message });
  }
};

/**
 * Get all leave requests for the current user
 * @route GET /api/leaves/my-leaves
 */
exports.getMyLeaves = async (req, res) => {
  try {
    const leaves = await Leave.findByUserId(req.user.id);
    res.json(leaves);
  } catch (error) {
    console.error('Error fetching user leave requests:', error);
    res.status(500).json({ message: 'Server error while fetching user leave requests', error: error.message });
  }
};

/**
 * Create a new leave request
 * @route POST /api/leaves
 */
exports.createLeave = async (req, res) => {
  try {
    const { leave_type, start_date, end_date, reason, supporting_document_url } = req.body;
    
    // Validate required fields
    if (!leave_type || !start_date || !end_date || !reason) {
      return res.status(400).json({ 
        message: 'Missing required fields',
        required: ['leave_type', 'start_date', 'end_date', 'reason']
      });
    }
    
    // Validate leave type
    const validTypes = ['conference', 'medical', 'family_emergency', 'personal', 'other'];
    if (!validTypes.includes(leave_type)) {
      return res.status(400).json({ 
        message: 'Invalid leave type', 
        validTypes 
      });
    }
    
    // Validate dates
    const startDate = new Date(start_date);
    const endDate = new Date(end_date);
    const today = new Date();
    
    if (isNaN(startDate.getTime()) || isNaN(endDate.getTime())) {
      return res.status(400).json({ message: 'Invalid date format' });
    }
    
    if (startDate > endDate) {
      return res.status(400).json({ message: 'Start date must be before end date' });
    }
    
    // Only admins can create backdated leave requests
    if (startDate < today && req.user.role !== 'admin') {
      return res.status(400).json({ message: 'Cannot request leave for past dates' });
    }
    
    // Check for conflicts with existing assignments
    const conflicts = await Leave.checkConflicts(req.user.id, start_date, end_date);
    
    // Create leave request
    const leaveResult = await Leave.create({
      user_id: req.user.id,
      leave_type,
      start_date,
      end_date,
      reason,
      supporting_document_url: supporting_document_url || null
    });
    
    // Get the created leave with details
    const createdLeave = await Leave.findById(leaveResult.id);
    
    // Return response with conflict warnings if any
    res.status(201).json({
      message: 'Leave request created successfully',
      leave: createdLeave,
      conflicts: conflicts.hasConflicts ? {
        message: 'Warning: You have assignments during the requested leave period',
        taskConflicts: conflicts.taskConflicts,
        examConflicts: conflicts.examConflicts
      } : null
    });
  } catch (error) {
    console.error('Error creating leave request:', error);
    res.status(500).json({ message: 'Server error while creating leave request', error: error.message });
  }
};

/**
 * Update the status of a leave request (approve/reject)
 * @route PUT /api/leaves/:id/status
 */
exports.updateLeaveStatus = async (req, res) => {
  try {
    const { status, reviewer_notes } = req.body;
    const leaveId = req.params.id;
    
    // Validate the status
    if (!status || !['approved', 'rejected'].includes(status)) {
      return res.status(400).json({ message: 'Invalid status. Must be "approved" or "rejected"' });
    }
    
    // Check if user has permission to approve/reject leaves
    if (req.user.role !== 'admin' && req.user.role !== 'department_chair' && req.user.role !== 'staff') {
      return res.status(403).json({ message: 'You do not have permission to approve or reject leave requests' });
    }
    
    // Get the leave request
    const leave = await Leave.findById(leaveId);
    
    if (!leave) {
      return res.status(404).json({ message: 'Leave request not found' });
    }
    
    // Only allow changes to pending requests
    if (leave.status !== 'pending') {
      return res.status(400).json({ 
        message: 'Cannot update status of a leave request that has already been processed', 
        currentStatus: leave.status
      });
    }
    
    // Update the leave request status
    const updated = await Leave.update(leaveId, status, req.user.id, reviewer_notes);
    
    if (!updated) {
      return res.status(400).json({ message: 'Failed to update leave request status' });
    }
    
    // Get the updated leave with details
    const updatedLeave = await Leave.findById(leaveId);
    
    res.json({
      message: `Leave request ${status}`,
      leave: updatedLeave
    });
  } catch (error) {
    console.error('Error updating leave request status:', error);
    res.status(500).json({ message: 'Server error while updating leave request status', error: error.message });
  }
};

/**
 * Delete a leave request
 * @route DELETE /api/leaves/:id
 */
exports.deleteLeave = async (req, res) => {
  try {
    const leaveId = req.params.id;
    
    // First check if the leave exists
    const leave = await Leave.findById(leaveId);
    
    if (!leave) {
      return res.status(404).json({ message: 'Leave request not found' });
    }
    
    // Check permissions - only the user who created it (if still pending) or an admin can delete
    if (req.user.role !== 'admin' && req.user.id !== leave.user_id) {
      return res.status(403).json({ message: 'You do not have permission to delete this leave request' });
    }
    
    if (req.user.role !== 'admin' && leave.status !== 'pending') {
      return res.status(400).json({ message: 'Cannot delete leave requests that have already been reviewed' });
    }
    
    // Delete the leave request
    const deleted = await Leave.delete(leaveId, req.user.id, req.user.role);
    
    if (!deleted) {
      return res.status(400).json({ message: 'Failed to delete leave request' });
    }
    
    res.json({ message: 'Leave request deleted successfully' });
  } catch (error) {
    console.error('Error deleting leave request:', error);
    res.status(500).json({ message: 'Server error while deleting leave request', error: error.message });
  }
};

/**
 * Get leave statistics
 * @route GET /api/leaves/statistics
 */
exports.getLeaveStatistics = async (req, res) => {
  try {
    // For normal users, get only their stats; for admins/department chairs/staff, get all stats
    const userId = (req.user.role === 'admin' || req.user.role === 'department_chair' || req.user.role === 'staff') ? 
      null : req.user.id;
    
    const statistics = await Leave.getLeaveStatistics(userId);
    res.json(statistics);
  } catch (error) {
    console.error('Error fetching leave statistics:', error);
    res.status(500).json({ message: 'Server error while fetching leave statistics', error: error.message });
  }
};
```

`backend/controllers/swapController.js`:

```js
// backend/controllers/swapController.js
const Swap = require('../models/Swap');

/**
 * Get all swap requests based on user role
 * @route GET /api/swaps
 */
exports.getAllSwaps = async (req, res) => {
  try {
    const swaps = await Swap.findAll(req.user.id, req.user.role);
    res.json(swaps);
  } catch (error) {
    console.error('Error fetching swap requests:', error);
    res.status(500).json({ message: 'Server error while fetching swap requests', error: error.message });
  }
};

/**
 * Get a specific swap request by ID
 * @route GET /api/swaps/:id
 */
exports.getSwapById = async (req, res) => {
  try {
    const swap = await Swap.findById(req.params.id);
    
    if (!swap) {
      return res.status(404).json({ message: 'Swap request not found' });
    }
    
    // Check if user has permission to view this swap request
    if (req.user.role !== 'admin' && 
        req.user.role !== 'department_chair' && 
        req.user.role !== 'staff' &&
        req.user.id !== swap.requester_id && 
        req.user.id !== swap.target_id) {
      return res.status(403).json({ message: 'You do not have permission to view this swap request' });
    }
    
    res.json(swap);
  } catch (error) {
    console.error('Error fetching swap request:', error);
    res.status(500).json({ message: 'Server error while fetching swap request', error: error.message });
  }
};

/**
 * Get all swap requests involving the current user
 * @route GET /api/swaps/my-swaps
 */
exports.getMySwaps = async (req, res) => {
  try {
    const swaps = await Swap.findByUserId(req.user.id);
    res.json(swaps);
  } catch (error) {
    console.error('Error fetching user swap requests:', error);
    res.status(500).json({ message: 'Server error while fetching user swap requests', error: error.message });
  }
};

/**
 * Create a new swap request
 * @route POST /api/swaps
 */
exports.createSwap = async (req, res) => {
  try {
    const { 
      target_id, 
      assignment_type, 
      original_assignment_id, 
      proposed_assignment_id,
      reason 
    } = req.body;
    
    // Validate required fields
    if (!target_id || !assignment_type || !original_assignment_id || !reason) {
      return res.status(400).json({ 
        message: 'Missing required fields',
        required: ['target_id', 'assignment_type', 'original_assignment_id', 'reason']
      });
    }
    
    // Validate type
    if (!['task', 'exam'].includes(assignment_type)) {
      return res.status(400).json({ message: 'Invalid assignment type. Must be "task" or "exam"' });
    }
    
    // Prevent self-swaps
    if (req.user.id === parseInt(target_id)) {
      return res.status(400).json({ message: 'Cannot create a swap request with yourself' });
    }
    
    // Create swap request
    try {
      const swapResult = await Swap.create({
        requester_id: req.user.id,
        target_id,
        assignment_type,
        original_assignment_id,
        proposed_assignment_id: proposed_assignment_id || null,
        reason
      });
      
      // Get the created swap with details
      const createdSwap = await Swap.findById(swapResult.id);
      
      res.status(201).json({
        message: 'Swap request created successfully',
        swap: createdSwap
      });
    } catch (error) {
      // Catch specific model errors and return appropriate response
      if (error.message.includes('not assigned') || 
          error.message.includes('not found')) {
        return res.status(400).json({ message: error.message });
      }
      throw error; // Re-throw other errors to be caught by the outer catch block
    }
  } catch (error) {
    console.error('Error creating swap request:', error);
    res.status(500).json({ message: 'Server error while creating swap request', error: error.message });
  }
};

/**
 * Update the status of a swap request (approve/reject)
 * @route PUT /api/swaps/:id/status
 */
exports.updateSwapStatus = async (req, res) => {
  try {
    const { status, reviewer_notes } = req.body;
    const swapId = req.params.id;
    
    // Validate the status
    if (!status || !['approved', 'rejected'].includes(status)) {
      return res.status(400).json({ message: 'Invalid status. Must be "approved" or "rejected"' });
    }
    
    // Get the swap request
    const swap = await Swap.findById(swapId);
    
    if (!swap) {
      return res.status(404).json({ message: 'Swap request not found' });
    }
    
    // Only allow changes to pending requests
    if (swap.status !== 'pending') {
      return res.status(400).json({ 
        message: 'Cannot update status of a swap request that has already been processed', 
        currentStatus: swap.status
      });
    }
    
    // Check permissions
    const isStaffOrAdmin = ['admin', 'department_chair', 'staff'].includes(req.user.role);
    const isTargetUser = req.user.id === swap.target_id;
    
    // Target user can respond to the request, or staff/admins can override
    if (!isStaffOrAdmin && !isTargetUser) {
      return res.status(403).json({ message: 'You do not have permission to update this swap request' });
    }
    
    try {
      // Update the swap request status
      const updateResult = await Swap.updateStatus(swapId, status, req.user.id, reviewer_notes);
      
      if (!updateResult.success) {
        return res.status(400).json({ message: 'Failed to update swap request status' });
      }
      
      // Get the updated swap with details
      const updatedSwap = await Swap.findById(swapId);
      
      res.json({
        message: `Swap request ${status}`,
        swap: updatedSwap
      });
    } catch (error) {
      // Catch specific model errors and return appropriate response
      if (error.message.includes('not found') || 
          error.message.includes('assignment not found')) {
        return res.status(400).json({ message: error.message });
      }
      throw error; // Re-throw other errors to be caught by the outer catch block
    }
  } catch (error) {
    console.error('Error updating swap request status:', error);
    res.status(500).json({ message: 'Server error while updating swap request status', error: error.message });
  }
};

/**
 * Delete a swap request
 * @route DELETE /api/swaps/:id
 */
exports.deleteSwap = async (req, res) => {
  try {
    const swapId = req.params.id;
    
    // First check if the swap exists
    const swap = await Swap.findById(swapId);
    
    if (!swap) {
      return res.status(404).json({ message: 'Swap request not found' });
    }
    
    // Check permissions - only the user who created it (if still pending) or an admin can delete
    if (req.user.role !== 'admin' && req.user.id !== swap.requester_id) {
      return res.status(403).json({ message: 'You do not have permission to delete this swap request' });
    }
    
    if (req.user.role !== 'admin' && swap.status !== 'pending') {
      return res.status(400).json({ message: 'Cannot delete swap requests that have already been reviewed' });
    }
    
    // Delete the swap request
    const deleted = await Swap.delete(swapId, req.user.id, req.user.role);
    
    if (!deleted) {
      return res.status(400).json({ message: 'Failed to delete swap request' });
    }
    
    res.json({ message: 'Swap request deleted successfully' });
  } catch (error) {
    console.error('Error deleting swap request:', error);
    res.status(500).json({ message: 'Server error while deleting swap request', error: error.message });
  }
};

/**
 * Get eligible target users for a swap
 * @route GET /api/swaps/eligible-targets/:assignmentId/:type
 */
exports.getEligibleTargets = async (req, res) => {
  try {
    const { assignmentId, type } = req.params;
    
    // Validate the type
    if (!['task', 'exam'].includes(type)) {
      return res.status(400).json({ message: 'Invalid type. Must be "task" or "exam"' });
    }
    
    const eligibleTargets = await Swap.getEligibleTargets(req.user.id, assignmentId, type);
    
    res.json(eligibleTargets);
  } catch (error) {
    console.error('Error fetching eligible targets:', error);
    res.status(500).json({ message: 'Server error while fetching eligible targets', error: error.message });
  }
};

/**
 * Get swap statistics
 * @route GET /api/swaps/statistics
 */
exports.getSwapStatistics = async (req, res) => {
  try {
    // For normal users, get only their stats; for admins/department chairs/staff, get all stats
    const userId = (req.user.role === 'admin' || req.user.role === 'department_chair' || req.user.role === 'staff') ? 
      null : req.user.id;
    
    const statistics = await Swap.getSwapStatistics(userId);
    res.json(statistics);
  } catch (error) {
    console.error('Error fetching swap statistics:', error);
    res.status(500).json({ message: 'Server error while fetching swap statistics', error: error.message });
  }
};
```

`backend/controllers/taskController.js`:

```js
// backend/controllers/taskController.js
const Task = require('../models/Task');

exports.getAllTasks = async (req, res) => {
  try {
    const tasks = await Task.findAll(req.user.id, req.user.role);
    res.json(tasks);
  } catch (error) {
    console.error('Error fetching tasks:', error);
    res.status(500).json({ message: 'Server error while fetching tasks' });
  }
};

exports.getTaskById = async (req, res) => {
  try {
    const task = await Task.findById(req.params.id);
    
    if (!task) {
      return res.status(404).json({ message: 'Task not found' });
    }
    
    res.json(task);
  } catch (error) {
    console.error('Error fetching task:', error);
    res.status(500).json({ message: 'Server error while fetching task' });
  }
};

exports.getUpcomingTasks = async (req, res) => {
  try {
    const limit = req.query.limit ? parseInt(req.query.limit) : 5;
    const tasks = await Task.findUpcoming(req.user.id, limit);
    res.json(tasks);
  } catch (error) {
    console.error('Error fetching upcoming tasks:', error);
    res.status(500).json({ message: 'Server error while fetching upcoming tasks' });
  }
};

exports.createTask = async (req, res) => {
  try {
    // Check if user has permission to create tasks
    if (!['admin', 'staff', 'department_chair'].includes(req.user.role)) {
      return res.status(403).json({ message: 'You do not have permission to create tasks' });
    }
    
    // Validate the required fields
    const { title, task_type, due_date, duration } = req.body;
    
    if (!title || !task_type || !due_date || !duration) {
      return res.status(400).json({ message: 'Missing required fields' });
    }
    
    // Add the creator's ID to the task data
    const taskData = {
      ...req.body,
      created_by: req.user.id
    };
    
    const newTask = await Task.create(taskData);
    res.status(201).json(newTask);
  } catch (error) {
    console.error('Error creating task:', error);
    res.status(500).json({ message: 'Server error while creating task' });
  }
};

exports.updateTask = async (req, res) => {
  try {
    const taskId = req.params.id;
    
    // Get the existing task
    const task = await Task.findById(taskId);
    
    if (!task) {
      return res.status(404).json({ message: 'Task not found' });
    }
    
    // Check permissions - only creator or admin can update
    if (task.created_by !== req.user.id && req.user.role !== 'admin') {
      return res.status(403).json({ message: 'You do not have permission to update this task' });
    }
    
    const updated = await Task.update(taskId, req.body);
    
    if (!updated) {
      return res.status(400).json({ message: 'Failed to update task' });
    }
    
    const updatedTask = await Task.findById(taskId);
    res.json(updatedTask);
  } catch (error) {
    console.error('Error updating task:', error);
    res.status(500).json({ message: 'Server error while updating task' });
  }
};

exports.completeTask = async (req, res) => {
  try {
    const taskId = req.params.id;
    const result = await Task.complete(taskId, req.user.id, req.user.role);
    
    if (!result.success) {
      return res.status(400).json({ message: result.message });
    }
    
    res.json({ message: result.message });
  } catch (error) {
    console.error('Error completing task:', error);
    res.status(500).json({ message: 'Server error while completing task' });
  }
};

exports.deleteTask = async (req, res) => {
  try {
    const taskId = req.params.id;
    
    // Get the existing task
    const task = await Task.findById(taskId);
    
    if (!task) {
      return res.status(404).json({ message: 'Task not found' });
    }
    
    // Check permissions - only creator or admin can delete
    if (task.created_by !== req.user.id && req.user.role !== 'admin') {
      return res.status(403).json({ message: 'You do not have permission to delete this task' });
    }
    
    const deleted = await Task.delete(taskId);
    
    if (!deleted) {
      return res.status(400).json({ message: 'Failed to delete task' });
    }
    
    res.json({ message: 'Task deleted successfully' });
  } catch (error) {
    console.error('Error deleting task:', error);
    res.status(500).json({ message: 'Server error while deleting task' });
  }
};

```

`backend/middleware/authMiddleware.js`:

```js
const jwt = require('jsonwebtoken');
const { jwtSecret } = require('../config/auth');
const User = require('../models/User');

exports.protect = async (req, res, next) => {
  try {
    // Get token from header
    const token = req.header('Authorization')?.replace('Bearer ', '');

    if (!token) {
      return res.status(401).json({ message: 'Not authorized, no token' });
    }

    // Verify token
    const decoded = jwt.verify(token, jwtSecret);

    // Find user by ID
    const user = await User.findById(decoded.id);
    
    if (!user) {
      return res.status(401).json({ message: 'User not found' });
    }

    // Add user to request object
    req.user = {
      id: user.id,
      bilkentId: user.bilkent_id,
      email: user.email,
      role: user.role
    };

    next();
  } catch (error) {
    console.error('Auth middleware error:', error);
    if (error.name === 'JsonWebTokenError') {
      return res.status(401).json({ message: 'Invalid token' });
    }
    if (error.name === 'TokenExpiredError') {
      return res.status(401).json({ message: 'Token expired' });
    }
    res.status(500).json({ message: 'Server error in auth middleware' });
  }
};

// Role-based authorization middleware
exports.authorize = (...roles) => {
  return (req, res, next) => {
    if (!req.user || !roles.includes(req.user.role)) {
      return res.status(403).json({ message: 'Forbidden: insufficient permissions' });
    }
    next();
  };
};

```

`backend/middleware/validationMiddleware.js`:

```js
// backend/middleware/validationMiddleware.js
const { body, validationResult } = require('express-validator');

/**
 * Custom middleware to validate request based on rules
 * @param {Array} validations - Array of validation rules
 * @returns {Function} - Express middleware function
 */
exports.validate = (validations) => {
  return async (req, res, next) => {
    // Run all validations
    await Promise.all(validations.map(validation => validation.run(req)));

    // Get validation errors
    const errors = validationResult(req);
    
    if (errors.isEmpty()) {
      return next();
    }

    // Format errors for response
    const formattedErrors = {};
    errors.array().forEach(error => {
      formattedErrors[error.path] = error.msg;
    });

    return res.status(400).json({
      message: 'Validation failed',
      errors: formattedErrors
    });
  };
};

// Validation rules for authentication
exports.authValidation = {
  signup: [
    body('bilkentId')
      .exists().withMessage('Bilkent ID is required')
      .isString().withMessage('Bilkent ID must be a string')
      .trim().notEmpty().withMessage('Bilkent ID cannot be empty'),
    
    body('email')
      .exists().withMessage('Email is required')
      .isEmail().withMessage('Must be a valid email address')
      .custom(value => {
        if (!value.endsWith('@bilkent.edu.tr')) {
          throw new Error('Must use a Bilkent email address (@bilkent.edu.tr)');
        }
        return true;
      }),
    
    body('fullName')
      .exists().withMessage('Full name is required')
      .isString().withMessage('Full name must be a string')
      .trim().notEmpty().withMessage('Full name cannot be empty'),
    
    body('password')
      .exists().withMessage('Password is required')
      .isString().withMessage('Password must be a string')
      .isLength({ min: 6 }).withMessage('Password must be at least 6 characters long'),
    
    body('role')
      .optional()
      .isIn(['ta', 'staff', 'department_chair', 'dean', 'admin'])
      .withMessage('Invalid role specified')
  ],
  
  login: [
    body('bilkentId')
      .exists().withMessage('Bilkent ID is required')
      .isString().withMessage('Bilkent ID must be a string')
      .trim().notEmpty().withMessage('Bilkent ID cannot be empty'),
    
    body('password')
      .exists().withMessage('Password is required')
      .isString().withMessage('Password must be a string')
      .notEmpty().withMessage('Password cannot be empty')
  ],
  
  recoverPassword: [
    body('bilkentId')
      .exists().withMessage('Bilkent ID is required')
      .isString().withMessage('Bilkent ID must be a string')
      .trim().notEmpty().withMessage('Bilkent ID cannot be empty')
  ],
  
  resetPassword: [
    body('token')
      .exists().withMessage('Token is required')
      .isString().withMessage('Token must be a string')
      .trim().notEmpty().withMessage('Token cannot be empty'),
    
    body('bilkentId')
      .exists().withMessage('Bilkent ID is required')
      .isString().withMessage('Bilkent ID must be a string')
      .trim().notEmpty().withMessage('Bilkent ID cannot be empty'),
    
    body('newPassword')
      .exists().withMessage('New password is required')
      .isString().withMessage('New password must be a string')
      .isLength({ min: 6 }).withMessage('New password must be at least 6 characters long')
  ]
};

// Parameter normalization middleware
exports.normalizeParams = (req, res, next) => {
  // Normalize common camelCase/snake_case parameter pairs
  const normalizations = [
    { camel: 'bilkentId', snake: 'bilkent_id' },
    { camel: 'fullName', snake: 'full_name' },
    { camel: 'newPassword', snake: 'new_password' }
  ];
  
  normalizations.forEach(({ camel, snake }) => {
    // If both are provided, prefer camelCase (but keep both for backward compatibility)
    if (req.body[camel] !== undefined && req.body[snake] === undefined) {
      req.body[snake] = req.body[camel];
    } else if (req.body[snake] !== undefined && req.body[camel] === undefined) {
      req.body[camel] = req.body[snake];
    }
  });
  
  next();
};
```

`backend/models/Leave.js`:

```js
// backend/models/Leave.js
const db = require('../config/db');

class Leave {
  static async findAll(userId = null, role = null) {
    try {
      // For TAs, return only their own leave requests
      if (userId && role === 'ta') {
        const [rows] = await db.query(
          `SELECT l.*, u.full_name as requester_name, u.bilkent_id as requester_bilkent_id
           FROM leave_requests l
           JOIN users u ON l.user_id = u.id
           WHERE l.user_id = ?
           ORDER BY l.created_at DESC`,
          [userId]
        );
        return rows;
      }

      // For department chairs, admins, and staff - return relevant leave requests
      if (role === 'department_chair' || role === 'admin' || role === 'staff') {
        // Department chairs and admins can see all leave requests
        const [rows] = await db.query(
          `SELECT l.*, u.full_name as requester_name, u.bilkent_id as requester_bilkent_id,
           r.full_name as reviewer_name
           FROM leave_requests l
           JOIN users u ON l.user_id = u.id
           LEFT JOIN users r ON l.reviewer_id = r.id
           ORDER BY l.created_at DESC`
        );
        return rows;
      }

      // Default case - shouldn't normally be reached with proper auth
      const [rows] = await db.query(
        `SELECT l.*, u.full_name as requester_name
         FROM leave_requests l
         JOIN users u ON l.user_id = u.id
         ORDER BY l.created_at DESC`
      );
      return rows;
    } catch (error) {
      throw error;
    }
  }

  static async findById(leaveId) {
    try {
      const [rows] = await db.query(
        `SELECT l.*, u.full_name as requester_name, u.bilkent_id as requester_bilkent_id, 
         u.email as requester_email, u.status as user_status,
         r.full_name as reviewer_name, r.bilkent_id as reviewer_bilkent_id
         FROM leave_requests l
         JOIN users u ON l.user_id = u.id
         LEFT JOIN users r ON l.reviewer_id = r.id
         WHERE l.id = ?`,
        [leaveId]
      );
      return rows[0];
    } catch (error) {
      throw error;
    }
  }

  static async findByUserId(userId) {
    try {
      const [rows] = await db.query(
        `SELECT l.*, r.full_name as reviewer_name
         FROM leave_requests l
         LEFT JOIN users r ON l.reviewer_id = r.id
         WHERE l.user_id = ? 
         ORDER BY l.created_at DESC`,
        [userId]
      );
      return rows;
    } catch (error) {
      throw error;
    }
  }

  static async create(leaveData) {
    try {
      const { user_id, leave_type, start_date, end_date, reason, supporting_document_url } = leaveData;
      
      // Calculate duration in days
      const startDate = new Date(start_date);
      const endDate = new Date(end_date);
      const duration = Math.ceil((endDate - startDate) / (1000 * 60 * 60 * 24)) + 1;

      // Start a transaction
      await db.query('START TRANSACTION');
      
      // Check for task conflicts 
      const [taskConflicts] = await db.query(
        `SELECT t.id, t.title, t.task_type, t.due_date, t.course_id 
         FROM tasks t 
         JOIN task_assignments ta ON t.id = ta.task_id 
         WHERE ta.user_id = ? 
         AND t.status = 'active' 
         AND t.due_date BETWEEN ? AND ?`,
        [user_id, start_date, end_date]
      );
      
      // Check for exam conflicts
      const [examConflicts] = await db.query(
        `SELECT e.id, e.exam_name as title, e.course_id, e.exam_date as due_date
         FROM exams e
         JOIN tasks t ON t.course_id = e.course_id AND t.task_type = 'proctoring'
         JOIN task_assignments ta ON t.id = ta.task_id 
         WHERE ta.user_id = ?
         AND e.exam_date BETWEEN ? AND ?`,
        [user_id, start_date, end_date]
      );

      // Insert the leave request
      const [result] = await db.query(
        `INSERT INTO leave_requests 
         (user_id, leave_type, start_date, end_date, duration, reason, supporting_document_url, status) 
         VALUES (?, ?, ?, ?, ?, ?, ?, 'pending')`,
        [user_id, leave_type, start_date, end_date, duration, reason, supporting_document_url]
      );
      
      // Add a system log entry for the leave request
      await db.query(
        `INSERT INTO system_logs (user_id, action, details, ip_address) 
         VALUES (?, 'leave_requested', ?, NULL)`,
        [
          user_id, 
          JSON.stringify({
            leave_id: result.insertId,
            leave_type,
            start_date,
            end_date,
            has_conflicts: taskConflicts.length > 0 || examConflicts.length > 0
          })
        ]
      );

      // Commit the transaction
      await db.query('COMMIT');
      
      // Return conflicts if any
      return {
        id: result.insertId,
        conflicts: {
          taskConflicts: taskConflicts.length > 0 ? taskConflicts : null,
          examConflicts: examConflicts.length > 0 ? examConflicts : null,
          hasConflicts: taskConflicts.length > 0 || examConflicts.length > 0
        }
      };
    } catch (error) {
      // Rollback the transaction on error
      await db.query('ROLLBACK');
      throw error;
    }
  }

  static async update(leaveId, status, reviewer_id, reviewer_notes = null) {
    try {
      // Start a transaction
      await db.query('START TRANSACTION');
      
      // Get the leave request details
      const [leaveDetails] = await db.query(
        'SELECT * FROM leave_requests WHERE id = ?',
        [leaveId]
      );
      
      if (leaveDetails.length === 0) {
        await db.query('ROLLBACK');
        throw new Error('Leave request not found');
      }
      
      const leave = leaveDetails[0];
      
      // Update the leave request status
      const [result] = await db.query(
        `UPDATE leave_requests 
         SET status = ?, reviewer_id = ?, reviewer_notes = ?, reviewed_at = CURRENT_TIMESTAMP 
         WHERE id = ?`,
        [status, reviewer_id, reviewer_notes, leaveId]
      );
      
      // If approved, add a system log entry 
      if (status === 'approved') {
        // Add a system log entry
        await db.query(
          `INSERT INTO system_logs (user_id, action, details, ip_address) 
           VALUES (?, 'leave_approved', ?, NULL)`,
          [
            reviewer_id, 
            JSON.stringify({
              leave_id: leaveId,
              user_id: leave.user_id,
              start_date: leave.start_date,
              end_date: leave.end_date
            })
          ]
        );
        
        // We don't automatically change user status to 'on_leave' here
        // That should be handled by a separate scheduled job or admin action
      } else if (status === 'rejected') {
        // Add a system log entry for rejection
        await db.query(
          `INSERT INTO system_logs (user_id, action, details, ip_address) 
           VALUES (?, 'leave_rejected', ?, NULL)`,
          [
            reviewer_id, 
            JSON.stringify({
              leave_id: leaveId,
              user_id: leave.user_id,
              reason: reviewer_notes
            })
          ]
        );
      }
      
      // Commit the transaction
      await db.query('COMMIT');
      
      return result.affectedRows > 0;
    } catch (error) {
      // Rollback the transaction on error
      await db.query('ROLLBACK');
      throw error;
    }
  }

  static async delete(leaveId, userId, role) {
    try {
      // Start a transaction
      await db.query('START TRANSACTION');
      
      // Only allow deletion of pending leaves by the requester or an admin
      let query = 'DELETE FROM leave_requests WHERE id = ?';
      let params = [leaveId];

      if (role !== 'admin') {
        query += ' AND user_id = ? AND status = "pending"';
        params.push(userId);
      }

      const [result] = await db.query(query, params);
      
      // Log the deletion if successful
      if (result.affectedRows > 0) {
        await db.query(
          `INSERT INTO system_logs (user_id, action, details, ip_address) 
           VALUES (?, 'leave_deleted', ?, NULL)`,
          [
            userId,
            JSON.stringify({
              leave_id: leaveId
            })
          ]
        );
      }
      
      // Commit the transaction
      await db.query('COMMIT');
      
      return result.affectedRows > 0;
    } catch (error) {
      // Rollback the transaction on error
      await db.query('ROLLBACK');
      throw error;
    }
  }

  static async getLeaveStatistics(userId = null) {
    try {
      let query = `
        SELECT 
          COUNT(*) as total_requests,
          SUM(CASE WHEN status = 'approved' THEN 1 ELSE 0 END) as approved,
          SUM(CASE WHEN status = 'rejected' THEN 1 ELSE 0 END) as rejected,
          SUM(CASE WHEN status = 'pending' THEN 1 ELSE 0 END) as pending,
          SUM(CASE WHEN status = 'approved' THEN duration ELSE 0 END) as total_days_taken
        FROM leave_requests
      `;
      
      let params = [];
      
      if (userId) {
        query += ' WHERE user_id = ?';
        params.push(userId);
      }
      
      const [rows] = await db.query(query, params);
      return rows[0];
    } catch (error) {
      throw error;
    }
  }

  static async checkConflicts(userId, startDate, endDate) {
    try {
      // Check for conflicts with tasks
      const [taskConflicts] = await db.query(
        `SELECT t.id, t.title, t.task_type, t.due_date, t.course_id 
         FROM tasks t 
         JOIN task_assignments ta ON t.id = ta.task_id 
         WHERE ta.user_id = ? 
         AND t.status = 'active' 
         AND t.due_date BETWEEN ? AND ?`,
        [userId, startDate, endDate]
      );
      
      // Check for conflicts with exams 
      const [examConflicts] = await db.query(
        `SELECT e.id, e.exam_name as title, e.course_id, e.exam_date as due_date
         FROM exams e
         JOIN tasks t ON t.course_id = e.course_id AND t.task_type = 'proctoring'
         JOIN task_assignments ta ON t.id = ta.task_id 
         WHERE ta.user_id = ?
         AND e.exam_date BETWEEN ? AND ?`,
        [userId, startDate, endDate]
      );
      
      return {
        hasConflicts: taskConflicts.length > 0 || examConflicts.length > 0,
        taskConflicts,
        examConflicts
      };
    } catch (error) {
      throw error;
    }
  }
}

module.exports = Leave;
```

`backend/models/Swap.js`:

```js
// backend/models/Swap.js
const db = require('../config/db');

class Swap {
  static async findAll(userId = null, role = null) {
    try {
      // For TAs, return swaps they're involved in (either as requester or target)
      if (userId && role === 'ta') {
        const [rows] = await db.query(
          `SELECT s.*, 
            r.full_name as requester_name, r.bilkent_id as requester_bilkent_id,
            t.full_name as target_name, t.bilkent_id as target_bilkent_id,
            CASE 
              WHEN s.assignment_type = 'task' THEN task.title
              WHEN s.assignment_type = 'exam' THEN exam.exam_name
            END as assignment_title,
            CASE 
              WHEN s.assignment_type = 'task' THEN task.task_type
              WHEN s.assignment_type = 'exam' THEN 'exam'
            END as assignment_subtype
          FROM swap_requests s
          JOIN users r ON s.requester_id = r.id
          JOIN users t ON s.target_id = t.id
          LEFT JOIN tasks task ON s.original_assignment_id = task.id AND s.assignment_type = 'task'
          LEFT JOIN exams exam ON s.original_assignment_id = exam.id AND s.assignment_type = 'exam'
          WHERE s.requester_id = ? OR s.target_id = ?
          ORDER BY s.created_at DESC`,
          [userId, userId]
        );
        return rows;
      }
      
      // For staff, department chair, and admin, return all swap requests
      if (role === 'staff' || role === 'department_chair' || role === 'admin') {
        const [rows] = await db.query(
          `SELECT s.*, 
            r.full_name as requester_name, r.bilkent_id as requester_bilkent_id,
            t.full_name as target_name, t.bilkent_id as target_bilkent_id,
            CASE 
              WHEN s.assignment_type = 'task' THEN task.title
              WHEN s.assignment_type = 'exam' THEN exam.exam_name
            END as assignment_title,
            CASE 
              WHEN s.assignment_type = 'task' THEN task.task_type
              WHEN s.assignment_type = 'exam' THEN 'exam'
            END as assignment_subtype
          FROM swap_requests s
          JOIN users r ON s.requester_id = r.id
          JOIN users t ON s.target_id = t.id
          LEFT JOIN tasks task ON s.original_assignment_id = task.id AND s.assignment_type = 'task'
          LEFT JOIN exams exam ON s.original_assignment_id = exam.id AND s.assignment_type = 'exam'
          ORDER BY s.created_at DESC`
        );
        return rows;
      }
      
      // Default fallback
      const [rows] = await db.query(
        `SELECT s.*, 
          r.full_name as requester_name, 
          t.full_name as target_name
        FROM swap_requests s
        JOIN users r ON s.requester_id = r.id
        JOIN users t ON s.target_id = t.id
        ORDER BY s.created_at DESC`
      );
      return rows;
    } catch (error) {
      throw error;
    }
  }

  static async findById(swapId) {
    try {
      const [rows] = await db.query(
        `SELECT s.*, 
          r.full_name as requester_name, r.bilkent_id as requester_bilkent_id, r.email as requester_email,
          t.full_name as target_name, t.bilkent_id as target_bilkent_id, t.email as target_email,
          CASE 
            WHEN s.assignment_type = 'task' THEN task.title
            WHEN s.assignment_type = 'exam' THEN exam.exam_name
          END as assignment_title,
          CASE
            WHEN s.assignment_type = 'task' THEN task.task_type
            WHEN s.assignment_type = 'exam' THEN 'exam'
          END as assignment_subtype,
          CASE
            WHEN s.assignment_type = 'task' THEN task.course_id
            WHEN s.assignment_type = 'exam' THEN exam.course_id
          END as course_id,
          rev.full_name as reviewer_name
        FROM swap_requests s
        JOIN users r ON s.requester_id = r.id
        JOIN users t ON s.target_id = t.id
        LEFT JOIN tasks task ON s.original_assignment_id = task.id AND s.assignment_type = 'task'
        LEFT JOIN exams exam ON s.original_assignment_id = exam.id AND s.assignment_type = 'exam'
        LEFT JOIN users rev ON s.reviewer_id = rev.id
        WHERE s.id = ?`,
        [swapId]
      );
      return rows[0];
    } catch (error) {
      throw error;
    }
  }

  static async findByUserId(userId) {
    try {
      const [rows] = await db.query(
        `SELECT s.*, 
          r.full_name as requester_name,
          t.full_name as target_name,
          CASE 
            WHEN s.assignment_type = 'task' THEN task.title
            WHEN s.assignment_type = 'exam' THEN exam.exam_name
          END as assignment_title,
          CASE 
            WHEN s.assignment_type = 'task' THEN task.task_type
            WHEN s.assignment_type = 'exam' THEN 'exam'
          END as assignment_subtype
        FROM swap_requests s
        JOIN users r ON s.requester_id = r.id
        JOIN users t ON s.target_id = t.id
        LEFT JOIN tasks task ON s.original_assignment_id = task.id AND s.assignment_type = 'task'
        LEFT JOIN exams exam ON s.original_assignment_id = exam.id AND s.assignment_type = 'exam'
        WHERE s.requester_id = ? OR s.target_id = ?
        ORDER BY s.created_at DESC`,
        [userId, userId]
      );
      return rows;
    } catch (error) {
      throw error;
    }
  }

  static async create(swapData) {
    try {
      const { 
        requester_id, 
        target_id, 
        assignment_type, 
        original_assignment_id, 
        proposed_assignment_id,
        reason 
      } = swapData;
      
      // Start a transaction
      await db.query('START TRANSACTION');
      
      // Check if the requester is eligible for the swap
      if (assignment_type === 'task') {
        // Check if the requester is assigned to the original task
        const [requesterAssignment] = await db.query(
          'SELECT * FROM task_assignments WHERE task_id = ? AND user_id = ?',
          [original_assignment_id, requester_id]
        );
        
        if (requesterAssignment.length === 0) {
          await db.query('ROLLBACK');
          throw new Error('Requester is not assigned to the original task');
        }
        
        // If proposed assignment is specified, check if target is assigned to it
        if (proposed_assignment_id) {
          const [targetAssignment] = await db.query(
            'SELECT * FROM task_assignments WHERE task_id = ? AND user_id = ?',
            [proposed_assignment_id, target_id]
          );
          
          if (targetAssignment.length === 0) {
            await db.query('ROLLBACK');
            throw new Error('Target is not assigned to the proposed task');
          }
        }
      } else if (assignment_type === 'exam') {
        // For exams, find the related proctoring task
        const [examInfo] = await db.query('SELECT * FROM exams WHERE id = ?', [original_assignment_id]);
        
        if (examInfo.length === 0) {
          await db.query('ROLLBACK');
          throw new Error('Exam not found');
        }
        
        const exam = examInfo[0];
        
        // Find proctoring task related to this exam for the requester
        const [requesterTask] = await db.query(
          `SELECT t.id, ta.id as assignment_id 
           FROM tasks t 
           JOIN task_assignments ta ON t.id = ta.task_id 
           WHERE t.task_type = 'proctoring' 
           AND ta.user_id = ? 
           AND t.course_id = ?
           AND t.due_date = ?`,
          [requester_id, exam.course_id, exam.exam_date]
        );
        
        if (requesterTask.length === 0) {
          await db.query('ROLLBACK');
          throw new Error('Requester is not assigned to proctor this exam');
        }
        
        // If proposed assignment is specified, also check target's eligibility
        if (proposed_assignment_id) {
          const [proposedExamInfo] = await db.query('SELECT * FROM exams WHERE id = ?', [proposed_assignment_id]);
          
          if (proposedExamInfo.length === 0) {
            await db.query('ROLLBACK');
            throw new Error('Proposed exam not found');
          }
          
          const proposedExam = proposedExamInfo[0];
          
          // Find proctoring task related to this exam for the target
          const [targetTask] = await db.query(
            `SELECT t.id, ta.id as assignment_id 
             FROM tasks t 
             JOIN task_assignments ta ON t.id = ta.task_id 
             WHERE t.task_type = 'proctoring' 
             AND ta.user_id = ? 
             AND t.course_id = ?
             AND t.due_date = ?`,
            [target_id, proposedExam.course_id, proposedExam.exam_date]
          );
          
          if (targetTask.length === 0) {
            await db.query('ROLLBACK');
            throw new Error('Target is not assigned to proctor the proposed exam');
          }
        }
      }
      
      // Insert the swap request
      const [result] = await db.query(
        `INSERT INTO swap_requests 
         (requester_id, target_id, assignment_type, original_assignment_id, proposed_assignment_id, reason, status) 
         VALUES (?, ?, ?, ?, ?, ?, 'pending')`,
        [requester_id, target_id, assignment_type, original_assignment_id, proposed_assignment_id, reason]
      );
      
      // Add a system log entry
      await db.query(
        `INSERT INTO system_logs (user_id, action, details, ip_address) 
         VALUES (?, 'swap_requested', ?, NULL)`,
        [
          requester_id, 
          JSON.stringify({
            swap_id: result.insertId,
            target_id,
            assignment_type,
            original_assignment_id
          })
        ]
      );
      
      // Commit the transaction
      await db.query('COMMIT');
      
      return {
        id: result.insertId,
        status: 'pending'
      };
    } catch (error) {
      // Rollback the transaction on error
      await db.query('ROLLBACK');
      throw error;
    }
  }

  static async updateStatus(swapId, status, reviewerId, reviewerNotes = null) {
    try {
      // Start a transaction
      await db.query('START TRANSACTION');
      
      // Get swap details
      const [swapDetails] = await db.query(
        'SELECT * FROM swap_requests WHERE id = ?',
        [swapId]
      );
      
      if (swapDetails.length === 0) {
        await db.query('ROLLBACK');
        throw new Error('Swap request not found');
      }
      
      const swap = swapDetails[0];
      
      // Update the swap request status
      const [updateResult] = await db.query(
        `UPDATE swap_requests 
         SET status = ?, reviewer_id = ?, reviewer_notes = ?, reviewed_at = CURRENT_TIMESTAMP 
         WHERE id = ?`,
        [status, reviewerId, reviewerNotes, swapId]
      );
      
      // If approved, perform the swap
      if (status === 'approved') {
        if (swap.assignment_type === 'task') {
          // Get the task assignments that need to be swapped
          const [requesterAssignment] = await db.query(
            'SELECT * FROM task_assignments WHERE task_id = ? AND user_id = ?',
            [swap.original_assignment_id, swap.requester_id]
          );
          
          if (requesterAssignment.length === 0) {
            await db.query('ROLLBACK');
            throw new Error('Requester task assignment not found');
          }
          
          if (swap.proposed_assignment_id) {
            // Two-way swap - get target's assignment
            const [targetAssignment] = await db.query(
              'SELECT * FROM task_assignments WHERE task_id = ? AND user_id = ?',
              [swap.proposed_assignment_id, swap.target_id]
            );
            
            if (targetAssignment.length === 0) {
              await db.query('ROLLBACK');
              throw new Error('Target task assignment not found');
            }
            
            // Update both assignments
            await db.query(
              'UPDATE task_assignments SET user_id = ? WHERE id = ?',
              [swap.target_id, requesterAssignment[0].id]
            );
            
            await db.query(
              'UPDATE task_assignments SET user_id = ? WHERE id = ?',
              [swap.requester_id, targetAssignment[0].id]
            );
          } else {
            // One-way swap - target takes over requester's task
            await db.query(
              'UPDATE task_assignments SET user_id = ? WHERE id = ?',
              [swap.target_id, requesterAssignment[0].id]
            );
          }
        } else if (swap.assignment_type === 'exam') {
          // For exam swaps, we need to find the associated proctoring tasks
          
          // Get exam details
          const [examInfo] = await db.query('SELECT * FROM exams WHERE id = ?', [swap.original_assignment_id]);
          if (examInfo.length === 0) {
            await db.query('ROLLBACK');
            throw new Error('Exam not found');
          }
          const exam = examInfo[0];
          
          // Find the proctoring task for the requester
          const [requesterTask] = await db.query(
            `SELECT t.id, ta.id as assignment_id 
             FROM tasks t 
             JOIN task_assignments ta ON t.id = ta.task_id 
             WHERE t.task_type = 'proctoring' 
             AND ta.user_id = ? 
             AND t.course_id = ?
             AND t.due_date = ?`,
            [swap.requester_id, exam.course_id, exam.exam_date]
          );
          
          if (requesterTask.length === 0) {
            await db.query('ROLLBACK');
            throw new Error('Requester proctoring task not found');
          }
          
          if (swap.proposed_assignment_id) {
            // Two-way swap
            const [proposedExamInfo] = await db.query('SELECT * FROM exams WHERE id = ?', [swap.proposed_assignment_id]);
            if (proposedExamInfo.length === 0) {
              await db.query('ROLLBACK');
              throw new Error('Proposed exam not found');
            }
            const proposedExam = proposedExamInfo[0];
            
            // Find proctoring task for the target
            const [targetTask] = await db.query(
              `SELECT t.id, ta.id as assignment_id 
               FROM tasks t 
               JOIN task_assignments ta ON t.id = ta.task_id 
               WHERE t.task_type = 'proctoring' 
               AND ta.user_id = ? 
               AND t.course_id = ?
               AND t.due_date = ?`,
              [swap.target_id, proposedExam.course_id, proposedExam.exam_date]
            );
            
            if (targetTask.length === 0) {
              await db.query('ROLLBACK');
              throw new Error('Target proctoring task not found');
            }
            
            // Update both assignments
            await db.query(
              'UPDATE task_assignments SET user_id = ? WHERE id = ?',
              [swap.target_id, requesterTask[0].assignment_id]
            );
            
            await db.query(
              'UPDATE task_assignments SET user_id = ? WHERE id = ?',
              [swap.requester_id, targetTask[0].assignment_id]
            );
          } else {
            // One-way swap
            await db.query(
              'UPDATE task_assignments SET user_id = ? WHERE id = ?',
              [swap.target_id, requesterTask[0].assignment_id]
            );
          }
        }
        
        // Add system log for the approved swap
        await db.query(
          `INSERT INTO system_logs (user_id, action, details, ip_address) 
           VALUES (?, 'swap_approved', ?, NULL)`,
          [
            reviewerId, 
            JSON.stringify({
              swap_id: swapId,
              requester_id: swap.requester_id,
              target_id: swap.target_id
            })
          ]
        );
      } else if (status === 'rejected') {
        // Add system log for the rejected swap
        await db.query(
          `INSERT INTO system_logs (user_id, action, details, ip_address) 
           VALUES (?, 'swap_rejected', ?, NULL)`,
          [
            reviewerId, 
            JSON.stringify({
              swap_id: swapId,
              requester_id: swap.requester_id,
              target_id: swap.target_id,
              reason: reviewerNotes
            })
          ]
        );
      }
      
      // Commit the transaction
      await db.query('COMMIT');
      
      return {
        success: updateResult.affectedRows > 0,
        status
      };
    } catch (error) {
      // Rollback the transaction on error
      await db.query('ROLLBACK');
      throw error;
    }
  }

  static async delete(swapId, userId, role) {
    try {
      // Only allow deletion of pending swaps by the requester or an admin
      let query = 'DELETE FROM swap_requests WHERE id = ?';
      let params = [swapId];

      if (role !== 'admin') {
        query += ' AND requester_id = ? AND status = "pending"';
        params.push(userId);
      }

      const [result] = await db.query(query, params);
      
      if (result.affectedRows > 0) {
        // Log the deletion
        await db.query(
          `INSERT INTO system_logs (user_id, action, details, ip_address) 
           VALUES (?, 'swap_deleted', ?, NULL)`,
          [userId, JSON.stringify({ swap_id: swapId })]
        );
      }
      
      return result.affectedRows > 0;
    } catch (error) {
      throw error;
    }
  }

  static async getEligibleTargets(requesterId, assignmentId, type) {
    try {
      let eligibleUsers = [];
      
      if (type === 'task') {
        // Get task details
        const [taskDetails] = await db.query(
          'SELECT * FROM tasks WHERE id = ?', 
          [assignmentId]
        );
        
        if (taskDetails.length === 0) {
          throw new Error('Task not found');
        }
        
        const task = taskDetails[0];
        
        // Find TAs not on leave who have appropriate skills
        const [users] = await db.query(
          `SELECT u.id, u.full_name, u.bilkent_id, u.email
           FROM users u
           WHERE u.role = 'ta'
           AND u.status = 'active'
           AND u.id != ?
           AND NOT EXISTS (
             SELECT 1 FROM leave_requests lr
             WHERE lr.user_id = u.id
             AND lr.status = 'approved'
             AND ? BETWEEN lr.start_date AND lr.end_date
           )
           ORDER BY u.full_name`,
          [requesterId, task.due_date]
        );
        
        eligibleUsers = users;
      } else if (type === 'exam') {
        // Get exam details
        const [examDetails] = await db.query(
          'SELECT * FROM exams WHERE id = ?', 
          [assignmentId]
        );
        
        if (examDetails.length === 0) {
          throw new Error('Exam not found');
        }
        
        const exam = examDetails[0];
        
        // Find TAs not on leave during the exam date
        const [users] = await db.query(
          `SELECT u.id, u.full_name, u.bilkent_id, u.email
           FROM users u
           WHERE u.role = 'ta'
           AND u.status = 'active'
           AND u.id != ?
           AND NOT EXISTS (
             SELECT 1 FROM leave_requests lr
             WHERE lr.user_id = u.id
             AND lr.status = 'approved'
             AND ? BETWEEN lr.start_date AND lr.end_date
           )
           ORDER BY u.full_name`,
          [requesterId, exam.exam_date]
        );
        
        eligibleUsers = users;
      }
      
      return eligibleUsers;
    } catch (error) {
      throw error;
    }
  }

  static async getSwapStatistics(userId = null) {
    try {
      let query = `
        SELECT 
          COUNT(*) as total_swaps,
          SUM(CASE WHEN status = 'approved' THEN 1 ELSE 0 END) as approved,
          SUM(CASE WHEN status = 'rejected' THEN 1 ELSE 0 END) as rejected,
          SUM(CASE WHEN status = 'pending' THEN 1 ELSE 0 END) as pending,
          SUM(CASE WHEN assignment_type = 'task' THEN 1 ELSE 0 END) as task_swaps,
          SUM(CASE WHEN assignment_type = 'exam' THEN 1 ELSE 0 END) as exam_swaps
        FROM swap_requests
      `;
      
      let params = [];
      
      if (userId) {
        query += ' WHERE requester_id = ? OR target_id = ?';
        params.push(userId, userId);
      }
      
      const [rows] = await db.query(query, params);
      return rows[0];
    } catch (error) {
      throw error;
    }
  }
}

module.exports = Swap;
```

`backend/models/Task.js`:

```js
// backend/models/Task.js
const db = require('../config/db');

class Task {
  static async findAll(userId = null, role = null) {
    try {
      // If userId is provided, return tasks assigned to that user (for TAs)
      if (userId && role === 'ta') {
        const [rows] = await db.query(
          `SELECT t.*, u.full_name as assigned_to_name
          FROM tasks t
          JOIN task_assignments ta ON t.id = ta.task_id
          JOIN users u ON u.id = ta.user_id
          WHERE ta.user_id = ?
          ORDER BY t.due_date ASC`,
          [userId]
        );
        return rows;
      }
      
      // If user is staff/instructor, return all tasks created by them
      if (userId && (role === 'staff' || role === 'department_chair')) {
        const [rows] = await db.query(
          `SELECT t.*, u.full_name as assigned_to_name
          FROM tasks t
          LEFT JOIN task_assignments ta ON t.id = ta.task_id
          LEFT JOIN users u ON u.id = ta.user_id
          WHERE t.created_by = ?
          ORDER BY t.due_date ASC`,
          [userId]
        );
        return rows;
      }
      
      // If no userId or admin role, return all tasks
      const [rows] = await db.query(
        `SELECT t.*, u.full_name as assigned_to_name, c.full_name as creator_name
        FROM tasks t
        LEFT JOIN task_assignments ta ON t.id = ta.task_id
        LEFT JOIN users u ON u.id = ta.user_id
        LEFT JOIN users c ON c.id = t.created_by
        ORDER BY t.due_date ASC`
      );
      return rows;
    } catch (error) {
      throw error;
    }
  }

  static async findById(taskId) {
    try {
      const [rows] = await db.query(
        `SELECT t.*, u.full_name as assigned_to_name, c.full_name as creator_name
        FROM tasks t
        LEFT JOIN task_assignments ta ON t.id = ta.task_id
        LEFT JOIN users u ON u.id = ta.user_id
        LEFT JOIN users c ON c.id = t.created_by
        WHERE t.id = ?`,
        [taskId]
      );
      return rows[0];
    } catch (error) {
      throw error;
    }
  }

  static async findUpcoming(userId, limit = 5) {
    try {
      const [rows] = await db.query(
        `SELECT t.*, u.full_name as assigned_to_name
        FROM tasks t
        JOIN task_assignments ta ON t.id = ta.task_id
        JOIN users u ON u.id = ta.user_id
        WHERE ta.user_id = ? AND t.status = 'active' AND t.due_date >= CURDATE()
        ORDER BY t.due_date ASC
        LIMIT ?`,
        [userId, limit]
      );
      return rows;
    } catch (error) {
      throw error;
    }
  }

  static async create(taskData) {
    try {
      const { title, description, task_type, course_id, due_date, duration, created_by } = taskData;
      
      const [result] = await db.query(
        `INSERT INTO tasks (title, description, task_type, course_id, due_date, duration, status, created_by)
        VALUES (?, ?, ?, ?, ?, ?, 'active', ?)`,
        [title, description, task_type, course_id, due_date, duration, created_by]
      );
      
      const taskId = result.insertId;
      
      // If there are assignees, create task assignments
      if (taskData.assignees && taskData.assignees.length > 0) {
        for (const userId of taskData.assignees) {
          await db.query(
            `INSERT INTO task_assignments (task_id, user_id)
            VALUES (?, ?)`,
            [taskId, userId]
          );
        }
      }
      
      return await this.findById(taskId);
    } catch (error) {
      throw error;
    }
  }

  static async update(taskId, taskData) {
    try {
      const { title, description, task_type, course_id, due_date, duration, status } = taskData;
      
      const [result] = await db.query(
        `UPDATE tasks
        SET title = ?, description = ?, task_type = ?, course_id = ?, due_date = ?, duration = ?, status = ?
        WHERE id = ?`,
        [title, description, task_type, course_id, due_date, duration, status, taskId]
      );
      
      // Update task assignments if needed
      if (taskData.assignees && taskData.assignees.length > 0) {
        // Remove existing assignments
        await db.query('DELETE FROM task_assignments WHERE task_id = ?', [taskId]);
        
        // Add new assignments
        for (const userId of taskData.assignees) {
          await db.query(
            `INSERT INTO task_assignments (task_id, user_id)
            VALUES (?, ?)`,
            [taskId, userId]
          );
        }
      }
      
      return result.affectedRows > 0;
    } catch (error) {
      throw error;
    }
  }

  static async complete(taskId, userId, userRole) {
    try {
      // Get the task to check if the user is assigned to it or created it
      const task = await this.findById(taskId);
      if (!task) {
        return { success: false, message: 'Task not found' };
      }
      
      // Allow task creator (instructors/staff) to complete the task
      if ((userRole === 'staff' || userRole === 'department_chair') && task.created_by === userId) {
        const [result] = await db.query(
          'UPDATE tasks SET status = "completed", completed_at = CURRENT_TIMESTAMP WHERE id = ?',
          [taskId]
        );
        
        return { 
          success: result.affectedRows > 0, 
          message: result.affectedRows > 0 ? 'Task marked as completed' : 'Failed to update task'
        };
      }
      
      // For other users, check if they are assigned to this task
      const [assignment] = await db.query(
        'SELECT * FROM task_assignments WHERE task_id = ? AND user_id = ?',
        [taskId, userId]
      );
      
      if (assignment.length === 0) {
        return { success: false, message: 'You are not assigned to this task' };
      }
      
      // Update the task status to completed
      const [result] = await db.query(
        'UPDATE tasks SET status = "completed", completed_at = CURRENT_TIMESTAMP WHERE id = ?',
        [taskId]
      );
      
      return { 
        success: result.affectedRows > 0, 
        message: result.affectedRows > 0 ? 'Task marked as completed' : 'Failed to update task'
      };
    } catch (error) {
      throw error;
    }
  }

  static async delete(taskId) {
    try {
      // First delete task assignments
      await db.query('DELETE FROM task_assignments WHERE task_id = ?', [taskId]);
      
      // Then delete the task
      const [result] = await db.query('DELETE FROM tasks WHERE id = ?', [taskId]);
      
      return result.affectedRows > 0;
    } catch (error) {
      throw error;
    }
  }
}

module.exports = Task;

```

`backend/models/User.js`:

```js
// backend/models/User.js
const db = require('../config/db');
const bcrypt = require('bcryptjs');

class User {
  static async findById(id) {
    try {
      const [rows] = await db.query(
        'SELECT id, bilkent_id, email, full_name, role FROM users WHERE id = ?',
        [id]
      );
      return rows[0];
    } catch (error) {
      throw error;
    }
  }

  static async findByBilkentId(bilkentId) {
    try {
      const [rows] = await db.query(
        'SELECT * FROM users WHERE bilkent_id = ?',
        [bilkentId]
      );
      return rows[0];
    } catch (error) {
      throw error;
    }
  }

  static async findByEmail(email) {
    try {
      const [rows] = await db.query(
        'SELECT * FROM users WHERE email = ?',
        [email]
      );
      return rows[0];
    } catch (error) {
      throw error;
    }
  }

  static async create(userData) {
    try {
      const hashedPassword = await bcrypt.hash(userData.password, 10);
      const [result] = await db.query(
        'INSERT INTO users (bilkent_id, email, password, full_name, role) VALUES (?, ?, ?, ?, ?)',
        [userData.bilkent_id, userData.email, hashedPassword, userData.full_name, userData.role]
      );
      return { 
        id: result.insertId,
        bilkent_id: userData.bilkent_id,
        email: userData.email,
        full_name: userData.full_name,
        role: userData.role
      };
    } catch (error) {
      throw error;
    }
  }

  static async updatePassword(bilkentId, newPassword) {
    try {
      const hashedPassword = await bcrypt.hash(newPassword, 10);
      const [result] = await db.query(
        'UPDATE users SET password = ? WHERE bilkent_id = ?',
        [hashedPassword, bilkentId]
      );
      return result.affectedRows > 0;
    } catch (error) {
      throw error;
    }
  }

  static async verifyPassword(plainPassword, hashedPassword) {
    return await bcrypt.compare(plainPassword, hashedPassword);
  }
}

module.exports = User;
```

`backend/package.json`:

```json
{
  "name": "ta-management-system-backend",
  "version": "1.0.0",
  "description": "Backend for TA Management System",
  "main": "server.js",
  "scripts": {
    "start": "node server.js",
    "dev": "nodemon server.js",
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [
    "ta-management",
    "express",
    "mysql"
  ],
  "author": "",
  "license": "ISC",
  "dependencies": {
    "bcryptjs": "^2.4.3",
    "cors": "^2.8.5",
    "dotenv": "^16.3.1",
    "express": "^4.18.2",
    "express-validator": "^7.0.1",
    "jsonwebtoken": "^9.0.2",
    "mysql2": "^3.6.1",
    "nodemailer": "^6.9.5"
  },
  "devDependencies": {
    "nodemon": "^3.1.10"
  }
}
```

`backend/routes/authRoutes.js`:

```js
// backend/routes/authRoutes.js
const express = require('express');
const router = express.Router();
const { 
  login, 
  recoverPassword, 
  resetPassword, 
  logout, 
  signup 
} = require('../controllers/authController');
const { protect } = require('../middleware/authMiddleware');
const { 
  validate, 
  authValidation, 
  normalizeParams 
} = require('../middleware/validationMiddleware');

// Apply parameter normalization middleware to all routes
router.use(normalizeParams);

/**
 * @route POST /api/auth/login
 * @desc Authenticate user & get token
 * @access Public
 */
router.post('/login', validate(authValidation.login), login);

/**
 * @route POST /api/auth/recover-password
 * @desc Send password recovery email
 * @access Public
 */
router.post('/recover-password', validate(authValidation.recoverPassword), recoverPassword);

/**
 * @route POST /api/auth/reset-password
 * @desc Reset user password
 * @access Public
 */
router.post('/reset-password', validate(authValidation.resetPassword), resetPassword);

/**
 * @route POST /api/auth/logout
 * @desc Logout user (client-side implementation)
 * @access Private
 */
router.post('/logout', protect, logout);

/**
 * @route POST /api/auth/signup
 * @desc Register a new user
 * @access Public
 */
router.post('/signup', validate(authValidation.signup), signup);

module.exports = router;
```

`backend/routes/leaveRoutes.js`:

```js
// backend/routes/leaveRoutes.js
const express = require('express');
const router = express.Router();
const { 
  getAllLeaves, 
  getLeaveById, 
  getMyLeaves,
  createLeave, 
  updateLeaveStatus, 
  deleteLeave,
  getLeaveStatistics
} = require('../controllers/leaveController');
const { protect, authorize } = require('../middleware/authMiddleware');

// All routes are protected and require authentication
router.use(protect);

/**
 * @route GET /api/leaves
 * @desc Get all leave requests (filtered by user role)
 * @access Private
 */
router.get('/', getAllLeaves);

/**
 * @route GET /api/leaves/my-leaves
 * @desc Get all leave requests for the current user
 * @access Private
 */
router.get('/my-leaves', getMyLeaves);

/**
 * @route GET /api/leaves/statistics
 * @desc Get leave request statistics
 * @access Private
 */
router.get('/statistics', getLeaveStatistics);

/**
 * @route GET /api/leaves/:id
 * @desc Get a specific leave request
 * @access Private
 */
router.get('/:id', getLeaveById);

/**
 * @route POST /api/leaves
 * @desc Create a new leave request
 * @access Private
 */
router.post('/', createLeave);

/**
 * @route PUT /api/leaves/:id/status
 * @desc Update a leave request status (approve/reject)
 * @access Private (department_chair, admin, staff)
 */
router.put('/:id/status', authorize('department_chair', 'admin', 'staff'), updateLeaveStatus);

/**
 * @route DELETE /api/leaves/:id
 * @desc Delete a leave request
 * @access Private
 */
router.delete('/:id', deleteLeave);

module.exports = router;
```

`backend/routes/swapRoutes.js`:

```js
// backend/routes/swapRoutes.js
const express = require('express');
const router = express.Router();
const { 
  getAllSwaps, 
  getSwapById, 
  getMySwaps,
  createSwap, 
  updateSwapStatus, 
  deleteSwap,
  getEligibleTargets,
  getSwapStatistics
} = require('../controllers/swapController');
const { protect } = require('../middleware/authMiddleware');

// All routes are protected and require authentication
router.use(protect);

/**
 * @route GET /api/swaps
 * @desc Get all swap requests (filtered by user role)
 * @access Private
 */
router.get('/', getAllSwaps);

/**
 * @route GET /api/swaps/my-swaps
 * @desc Get all swap requests involving the current user
 * @access Private
 */
router.get('/my-swaps', getMySwaps);

/**
 * @route GET /api/swaps/statistics
 * @desc Get swap request statistics
 * @access Private
 */
router.get('/statistics', getSwapStatistics);

/**
 * @route GET /api/swaps/eligible-targets/:assignmentId/:type
 * @desc Get eligible target users for a swap
 * @access Private
 */
router.get('/eligible-targets/:assignmentId/:type', getEligibleTargets);

/**
 * @route GET /api/swaps/:id
 * @desc Get a specific swap request
 * @access Private
 */
router.get('/:id', getSwapById);

/**
 * @route POST /api/swaps
 * @desc Create a new swap request
 * @access Private
 */
router.post('/', createSwap);

/**
 * @route PUT /api/swaps/:id/status
 * @desc Update a swap request status (approve/reject)
 * @access Private (requires being target user or a staff/admin)
 */
router.put('/:id/status', updateSwapStatus);

/**
 * @route DELETE /api/swaps/:id
 * @desc Delete a swap request
 * @access Private
 */
router.delete('/:id', deleteSwap);

module.exports = router;
```

`backend/routes/taskRoutes.js`:

```js
// backend/routes/taskRoutes.js
const express = require('express');
const router = express.Router();
const { 
  getAllTasks, 
  getTaskById, 
  getUpcomingTasks,
  createTask, 
  updateTask, 
  completeTask,
  deleteTask
} = require('../controllers/taskController');
const { protect, authorize } = require('../middleware/authMiddleware');

// All routes are protected and require authentication
router.use(protect);

// Get upcoming tasks
router.get('/upcoming', getUpcomingTasks);

// Get all tasks (filtered by user role & id)
router.get('/', getAllTasks);

// Get a specific task
router.get('/:id', getTaskById);

// Create a new task - only instructors, department chair, and admin can create tasks
router.post('/', authorize('staff', 'department_chair', 'admin'), createTask);

// Update a task
router.put('/:id', updateTask);

// Mark a task as completed
router.put('/:id/complete', completeTask);

// Delete a task
router.delete('/:id', deleteTask);

module.exports = router;

```

`backend/server.js`:

```js
// backend/server.js
require('dotenv').config();
const express = require('express');
const cors = require('cors');
const app = express();
const authRoutes = require('./routes/authRoutes');
const taskRoutes = require('./routes/taskRoutes');
const leaveRoutes = require('./routes/leaveRoutes');
const swapRoutes = require('./routes/swapRoutes');
const db = require('./config/db');

// Middleware
app.use(cors());
app.use(express.json());

// Test DB Connection
db.getConnection()
  .then(connection => {
    console.log('Database connection established');
    connection.release();
  })
  .catch(err => {
    console.error('Database connection failed:', err);
  });

// Routes
app.use('/api/auth', authRoutes);
app.use('/api/tasks', taskRoutes);
app.use('/api/leaves', leaveRoutes); // New route for leave management
app.use('/api/swaps', swapRoutes);   // New route for swap requests

// Simple health check endpoint
app.get('/health', (req, res) => {
  res.status(200).json({ status: 'ok', uptime: process.uptime() });
});

// Error handling middleware
app.use((err, req, res, next) => {
  console.error('Error:', err.stack);
  res.status(500).json({ 
    message: 'Something went wrong!',
    error: process.env.NODE_ENV === 'development' ? err.message : undefined
  });
});

// Handle 404 errors for undefined routes
app.use((req, res) => {
  res.status(404).json({ message: 'Route not found' });
});

const PORT = process.env.PORT || 5001;
app.listen(PORT, () => {
  console.log(`Server running on port ${PORT}`);
});
```
