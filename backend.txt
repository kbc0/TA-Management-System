Project Path: backend

Source Tree:

```txt
backend
├── config
│   ├── auth.js
│   └── db.js
├── controllers
│   ├── authController.js
│   └── taskController.js
├── docs
│   └── api-documentation.md
├── middleware
│   ├── authMiddleware.js
│   └── validationMiddleware.js
├── models
│   ├── Task.js
│   └── User.js
├── package.json
├── routes
│   ├── authRoutes.js
│   └── taskRoutes.js
└── server.js

```

`backend/config/auth.js`:

```js
module.exports = {
  jwtSecret: process.env.JWT_SECRET,
  jwtExpiresIn: '5000h'
};

```

`backend/config/db.js`:

```js
// backend/config/db.js
const mysql = require('mysql2/promise');

const pool = mysql.createPool({
  host: process.env.DB_HOST,
  user: process.env.DB_USER,
  password: process.env.DB_PASSWORD,
  database: process.env.DB_NAME,
  waitForConnections: true,
  connectionLimit: 10,
  queueLimit: 0
});

module.exports = pool;

```

`backend/controllers/authController.js`:

```js
// backend/controllers/authController.js
const User = require('../models/User');
const jwt = require('jsonwebtoken');
const { jwtSecret, jwtExpiresIn } = require('../config/auth');
const nodemailer = require('nodemailer');
const crypto = require('crypto');

// Store reset tokens temporarily (In production, use a database)
const resetTokens = {};

// Set up transporter for email
let transporter;

// Check if we're in development mode
if (process.env.NODE_ENV === 'development' || !process.env.MAIL_HOST) {
  console.log('Using mock email transport for development');
  // Create a mock transporter that logs emails instead of sending them
  transporter = {
    sendMail: async (mailOptions) => {
      console.log('Mock email sent:');
      console.log('To:', mailOptions.to);
      console.log('Subject:', mailOptions.subject);
      console.log('Content:', mailOptions.html || mailOptions.text);
      return { messageId: 'mock-email-id-' + Date.now() };
    }
  };
} else {
  // Use real nodemailer transport for production
  transporter = nodemailer.createTransport({
    host: process.env.MAIL_HOST,
    port: process.env.MAIL_PORT,
    secure: false,
    auth: {
      user: process.env.MAIL_USER,
      pass: process.env.MAIL_PASS
    }
  });
}

/**
 * Validates request parameters and returns missing or invalid fields
 * @param {Object} params - The parameters to validate
 * @param {Array} required - List of required field names
 * @returns {Object} - Object containing validation results
 */
const validateParams = (params, required) => {
  const missingFields = [];
  const errors = {};
  
  // Check for missing required fields
  required.forEach(field => {
    if (!params[field] && params[field] !== 0) {
      missingFields.push(field);
    }
  });
  
  // Email format validation (if email is provided)
  if (params.email && !params.email.endsWith('@bilkent.edu.tr')) {
    errors.email = 'Must use a Bilkent email address ending with @bilkent.edu.tr';
  }
  
  // Password strength validation (if password is provided)
  if (params.password && params.password.length < 6) {
    errors.password = 'Password must be at least 6 characters long';
  }
  
  return {
    isValid: missingFields.length === 0 && Object.keys(errors).length === 0,
    missingFields,
    errors
  };
};

/**
 * Register a new user
 * @route POST /api/auth/signup
 * @param {string} bilkentId - User's Bilkent ID
 * @param {string} email - User's email (must be @bilkent.edu.tr)
 * @param {string} fullName - User's full name
 * @param {string} password - User's password (min 6 characters)
 * @param {string} [role] - User's role (defaults to 'ta')
 */
exports.signup = async (req, res) => {
  try {
    // Normalize parameters - accept both camelCase and snake_case
    const bilkentId = req.body.bilkentId || req.body.bilkent_id;
    const email = req.body.email;
    const fullName = req.body.fullName || req.body.full_name;
    const password = req.body.password;
    const role = req.body.role;

    // Validate input
    const validation = validateParams(
      { bilkentId, email, fullName, password },
      ['bilkentId', 'email', 'fullName', 'password']
    );

    if (!validation.isValid) {
      const errorResponse = {
        message: 'Validation failed',
        details: {}
      };
      
      if (validation.missingFields.length > 0) {
        errorResponse.details.missingFields = validation.missingFields;
      }
      
      if (Object.keys(validation.errors).length > 0) {
        errorResponse.details.errors = validation.errors;
      }
      
      return res.status(400).json(errorResponse);
    }

    // Check if user already exists
    const existingUser = await User.findByBilkentId(bilkentId);
    if (existingUser) {
      return res.status(409).json({ message: 'User with this Bilkent ID already exists' });
    }

    // Check if email is already in use
    const emailExists = await User.findByEmail(email);
    if (emailExists) {
      return res.status(409).json({ message: 'Email is already in use' });
    }

    // Validate role (assuming roles are predefined)
    const validRoles = ['ta', 'staff', 'department_chair', 'dean', 'admin']; // Match database enum values
    if (role && !validRoles.includes(role)) {
      return res.status(400).json({ 
        message: 'Invalid role specified',
        validRoles
      });
    }

    // Create new user
    const newUser = await User.create({
      bilkent_id: bilkentId,
      email,
      full_name: fullName,
      password, // The User model should handle password hashing
      role: role || 'ta' // Default role if not specified
    });

    // Generate JWT token
    const token = jwt.sign(
      { id: newUser.id, bilkentId: newUser.bilkent_id, role: newUser.role },
      jwtSecret,
      { expiresIn: jwtExpiresIn }
    );

    // Return user data and token
    res.status(201).json({
      message: 'User registered successfully',
      token,
      user: {
        id: newUser.id,
        bilkentId: newUser.bilkent_id,
        email: newUser.email,
        fullName: newUser.full_name,
        role: newUser.role
      }
    });
  } catch (error) {
    console.error('Signup error:', error);
    res.status(500).json({ message: 'Server error during signup', error: error.message });
  }
};

/**
 * Log in a user
 * @route POST /api/auth/login
 * @param {string} bilkentId - User's Bilkent ID
 * @param {string} password - User's password
 */
exports.login = async (req, res) => {
  try {
    // Normalize parameters - accept both camelCase and snake_case
    const bilkentId = req.body.bilkentId || req.body.bilkent_id;
    const password = req.body.password;

    // Validate input
    const validation = validateParams(
      { bilkentId, password },
      ['bilkentId', 'password']
    );

    if (!validation.isValid) {
      const errorResponse = {
        message: 'Validation failed',
        details: {}
      };
      
      if (validation.missingFields.length > 0) {
        errorResponse.details.missingFields = validation.missingFields;
      }
      
      return res.status(400).json(errorResponse);
    }

    // Find user by BilkentID
    const user = await User.findByBilkentId(bilkentId);

    // Check if user exists
    if (!user) {
      return res.status(401).json({ message: 'Invalid credentials' });
    }

    // Verify password
    const isPasswordValid = await User.verifyPassword(password, user.password);
    if (!isPasswordValid) {
      return res.status(401).json({ message: 'Invalid credentials' });
    }

    // Generate JWT token
    const token = jwt.sign(
      { id: user.id, bilkentId: user.bilkent_id, role: user.role },
      jwtSecret,
      { expiresIn: jwtExpiresIn }
    );

    // Return user data and token
    res.json({
      token,
      user: {
        id: user.id,
        bilkentId: user.bilkent_id,
        email: user.email,
        fullName: user.full_name,
        role: user.role
      }
    });
  } catch (error) {
    console.error('Login error:', error);
    res.status(500).json({ message: 'Server error during login', error: error.message });
  }
};

/**
 * Send password recovery email
 * @route POST /api/auth/recover-password
 * @param {string} bilkentId - User's Bilkent ID
 */
exports.recoverPassword = async (req, res) => {
  try {
    // Normalize parameters
    const bilkentId = req.body.bilkentId || req.body.bilkent_id;

    // Validate input
    const validation = validateParams({ bilkentId }, ['bilkentId']);
    
    if (!validation.isValid) {
      const errorResponse = {
        message: 'Validation failed',
        details: {}
      };
      
      if (validation.missingFields.length > 0) {
        errorResponse.details.missingFields = validation.missingFields;
      }
      
      return res.status(400).json(errorResponse);
    }

    // Find user by BilkentID
    const user = await User.findByBilkentId(bilkentId);

    // If user doesn't exist, still show success to prevent email enumeration
    if (!user) {
      return res.json({ message: 'If your ID exists, a password reset link has been sent to your email' });
    }

    // Generate a reset token
    const resetToken = crypto.randomBytes(20).toString('hex');
    resetTokens[bilkentId] = {
      token: resetToken,
      expiresAt: Date.now() + 3600000 // Token expires in 1 hour
    };

    // Create reset URL
    const resetUrl = `${process.env.FRONTEND_URL || 'http://localhost:3000'}/reset-password/${resetToken}?id=${bilkentId}`;

    try {
      // Send email
      await transporter.sendMail({
        to: user.email,
        subject: 'Password Reset for TA Management System',
        html: `
          <p>Hello ${user.full_name},</p>
          <p>You requested a password reset for the TA Management System.</p>
          <p>Please click the link below to reset your password:</p>
          <a href="${resetUrl}">Reset Password</a>
          <p>If you didn't request this, please ignore this email.</p>
          <p>The link will expire in 1 hour.</p>
        `
      });
      
      console.log(`Password reset email sent to ${user.email}`);
    } catch (emailError) {
      console.error('Email sending failed:', emailError);
      // Continue with the process even if email fails
      // In production, you might want to log this to a monitoring system
    }

    res.json({ message: 'If your ID exists, a password reset link has been sent to your email' });
  } catch (error) {
    console.error('Password recovery error:', error);
    res.status(500).json({ message: 'Server error during password recovery', error: error.message });
  }
};

/**
 * Reset user password
 * @route POST /api/auth/reset-password
 * @param {string} token - Reset token
 * @param {string} bilkentId - User's Bilkent ID
 * @param {string} newPassword - New password
 */
exports.resetPassword = async (req, res) => {
  try {
    // Normalize parameters
    const token = req.body.token;
    const bilkentId = req.body.bilkentId || req.body.bilkent_id;
    const newPassword = req.body.newPassword || req.body.new_password;

    // Validate input
    const validation = validateParams(
      { token, bilkentId, newPassword },
      ['token', 'bilkentId', 'newPassword']
    );
    
    if (!validation.isValid) {
      const errorResponse = {
        message: 'Validation failed',
        details: {}
      };
      
      if (validation.missingFields.length > 0) {
        errorResponse.details.missingFields = validation.missingFields;
      }
      
      if (Object.keys(validation.errors).length > 0) {
        errorResponse.details.errors = validation.errors;
      }
      
      return res.status(400).json(errorResponse);
    }

    // Check if token exists and is valid
    if (!resetTokens[bilkentId] || 
        resetTokens[bilkentId].token !== token || 
        resetTokens[bilkentId].expiresAt < Date.now()) {
      return res.status(400).json({ message: 'Invalid or expired token' });
    }

    // Update password
    const updated = await User.updatePassword(bilkentId, newPassword);
    if (!updated) {
      return res.status(404).json({ message: 'User not found' });
    }

    // Remove used token
    delete resetTokens[bilkentId];

    res.json({ message: 'Password has been reset successfully' });
  } catch (error) {
    console.error('Password reset error:', error);
    res.status(500).json({ message: 'Server error during password reset', error: error.message });
  }
};

/**
 * Log out a user (client-side implementation)
 * @route POST /api/auth/logout
 */
exports.logout = (req, res) => {
  // JWT tokens are stateless, so we can't invalidate them on the server
  // The client should remove the token from storage
  res.json({ message: 'Logged out successfully' });
};
```

`backend/controllers/taskController.js`:

```js
// backend/controllers/taskController.js
const Task = require('../models/Task');

exports.getAllTasks = async (req, res) => {
  try {
    const tasks = await Task.findAll(req.user.id, req.user.role);
    res.json(tasks);
  } catch (error) {
    console.error('Error fetching tasks:', error);
    res.status(500).json({ message: 'Server error while fetching tasks' });
  }
};

exports.getTaskById = async (req, res) => {
  try {
    const task = await Task.findById(req.params.id);
    
    if (!task) {
      return res.status(404).json({ message: 'Task not found' });
    }
    
    res.json(task);
  } catch (error) {
    console.error('Error fetching task:', error);
    res.status(500).json({ message: 'Server error while fetching task' });
  }
};

exports.getUpcomingTasks = async (req, res) => {
  try {
    const limit = req.query.limit ? parseInt(req.query.limit) : 5;
    const tasks = await Task.findUpcoming(req.user.id, limit);
    res.json(tasks);
  } catch (error) {
    console.error('Error fetching upcoming tasks:', error);
    res.status(500).json({ message: 'Server error while fetching upcoming tasks' });
  }
};

exports.createTask = async (req, res) => {
  try {
    // Check if user has permission to create tasks
    if (!['admin', 'staff', 'department_chair'].includes(req.user.role)) {
      return res.status(403).json({ message: 'You do not have permission to create tasks' });
    }
    
    // Validate the required fields
    const { title, task_type, due_date, duration } = req.body;
    
    if (!title || !task_type || !due_date || !duration) {
      return res.status(400).json({ message: 'Missing required fields' });
    }
    
    // Add the creator's ID to the task data
    const taskData = {
      ...req.body,
      created_by: req.user.id
    };
    
    const newTask = await Task.create(taskData);
    res.status(201).json(newTask);
  } catch (error) {
    console.error('Error creating task:', error);
    res.status(500).json({ message: 'Server error while creating task' });
  }
};

exports.updateTask = async (req, res) => {
  try {
    const taskId = req.params.id;
    
    // Get the existing task
    const task = await Task.findById(taskId);
    
    if (!task) {
      return res.status(404).json({ message: 'Task not found' });
    }
    
    // Check permissions - only creator or admin can update
    if (task.created_by !== req.user.id && req.user.role !== 'admin') {
      return res.status(403).json({ message: 'You do not have permission to update this task' });
    }
    
    const updated = await Task.update(taskId, req.body);
    
    if (!updated) {
      return res.status(400).json({ message: 'Failed to update task' });
    }
    
    const updatedTask = await Task.findById(taskId);
    res.json(updatedTask);
  } catch (error) {
    console.error('Error updating task:', error);
    res.status(500).json({ message: 'Server error while updating task' });
  }
};

exports.completeTask = async (req, res) => {
  try {
    const taskId = req.params.id;
    const result = await Task.complete(taskId, req.user.id);
    
    if (!result.success) {
      return res.status(400).json({ message: result.message });
    }
    
    res.json({ message: result.message });
  } catch (error) {
    console.error('Error completing task:', error);
    res.status(500).json({ message: 'Server error while completing task' });
  }
};

exports.deleteTask = async (req, res) => {
  try {
    const taskId = req.params.id;
    
    // Get the existing task
    const task = await Task.findById(taskId);
    
    if (!task) {
      return res.status(404).json({ message: 'Task not found' });
    }
    
    // Check permissions - only creator or admin can delete
    if (task.created_by !== req.user.id && req.user.role !== 'admin') {
      return res.status(403).json({ message: 'You do not have permission to delete this task' });
    }
    
    const deleted = await Task.delete(taskId);
    
    if (!deleted) {
      return res.status(400).json({ message: 'Failed to delete task' });
    }
    
    res.json({ message: 'Task deleted successfully' });
  } catch (error) {
    console.error('Error deleting task:', error);
    res.status(500).json({ message: 'Server error while deleting task' });
  }
};

```

`backend/docs/api-documentation.md`:

```md
# TA Management System API Documentation

## Authentication Endpoints

### Sign Up
Register a new user in the system.

**URL**: `/api/auth/signup`  
**Method**: `POST`  
**Auth Required**: No

**Request Body**:
```json
{
  "bilkentId": "12345678",
  "email": "student@bilkent.edu.tr",
  "fullName": "John Doe",
  "password": "securepassword",
  "role": "ta"  // Optional, defaults to "ta"
}
```

**Notes**:
- `email` must end with `@bilkent.edu.tr`
- `password` must be at least 6 characters
- `role` must be one of: ["ta", "staff", "department_chair", "dean", "admin"]

**Success Response**:
- **Code**: 201 Created
- **Content**:
```json
{
  "message": "User registered successfully",
  "token": "jwt-token",
  "user": {
    "id": 1,
    "bilkentId": "12345678",
    "email": "student@bilkent.edu.tr",
    "fullName": "John Doe",
    "role": "ta"
  }
}
```

**Error Responses**:
- **Code**: 400 Bad Request
- **Condition**: Validation failed
- **Content**:
```json
{
  "message": "Validation failed",
  "errors": {
    "email": "Must use a Bilkent email address (@bilkent.edu.tr)",
    "password": "Password must be at least 6 characters long"
  }
}
```

- **Code**: 409 Conflict
- **Condition**: User already exists
- **Content**:
```json
{
  "message": "User with this Bilkent ID already exists"
}
```

### Login
Authenticate a user and get a token.

**URL**: `/api/auth/login`  
**Method**: `POST`  
**Auth Required**: No

**Request Body**:
```json
{
  "bilkentId": "12345678",
  "password": "securepassword"
}
```

**Success Response**:
- **Code**: 200 OK
- **Content**:
```json
{
  "token": "jwt-token",
  "user": {
    "id": 1,
    "bilkentId": "12345678",
    "email": "student@bilkent.edu.tr",
    "fullName": "John Doe",
    "role": "ta"
  }
}
```

**Error Responses**:
- **Code**: 400 Bad Request
- **Condition**: Validation failed
- **Content**:
```json
{
  "message": "Validation failed",
  "errors": {
    "bilkentId": "Bilkent ID is required"
  }
}
```

- **Code**: 401 Unauthorized
- **Condition**: Invalid credentials
- **Content**:
```json
{
  "message": "Invalid credentials"
}
```

### Recover Password
Request a password reset link.

**URL**: `/api/auth/recover-password`  
**Method**: `POST`  
**Auth Required**: No

**Request Body**:
```json
{
  "bilkentId": "12345678"
}
```

**Success Response**:
- **Code**: 200 OK
- **Content**:
```json
{
  "message": "If your ID exists, a password reset link has been sent to your email"
}
```

### Reset Password
Reset a user's password using a token.

**URL**: `/api/auth/reset-password`  
**Method**: `POST`  
**Auth Required**: No

**Request Body**:
```json
{
  "token": "reset-token",
  "bilkentId": "12345678",
  "newPassword": "newSecurePassword"
}
```

**Success Response**:
- **Code**: 200 OK
- **Content**:
```json
{
  "message": "Password has been reset successfully"
}
```

**Error Responses**:
- **Code**: 400 Bad Request
- **Condition**: Invalid token
- **Content**:
```json
{
  "message": "Invalid or expired token"
}
```

### Logout
Logout a user (client-side implementation).

**URL**: `/api/auth/logout`  
**Method**: `POST`  
**Auth Required**: Yes

**Headers**:
```
Authorization: Bearer {jwt-token}
```

**Success Response**:
- **Code**: 200 OK
- **Content**:
```json
{
  "message": "Logged out successfully"
}
```

## Task Management Endpoints

### Get All Tasks
Get all tasks based on user role.

**URL**: `/api/tasks`  
**Method**: `GET`  
**Auth Required**: Yes

**Headers**:
```
Authorization: Bearer {jwt-token}
```

**Success Response**:
- **Code**: 200 OK
- **Content**: Array of task objects

### Get Task by ID
Get details of a specific task.

**URL**: `/api/tasks/:id`  
**Method**: `GET`  
**Auth Required**: Yes

**Headers**:
```
Authorization: Bearer {jwt-token}
```

**Success Response**:
- **Code**: 200 OK
- **Content**: Task object

**Error Response**:
- **Code**: 404 Not Found
- **Content**:
```json
{
  "message": "Task not found"
}
```

### Get Upcoming Tasks
Get upcoming tasks for the current user.

**URL**: `/api/tasks/upcoming`  
**Method**: `GET`  
**Auth Required**: Yes

**Headers**:
```
Authorization: Bearer {jwt-token}
```

**Query Parameters**:
- `limit` (optional): Number of tasks to return (default: 5)

**Success Response**:
- **Code**: 200 OK
- **Content**: Array of task objects

### Create Task
Create a new task.

**URL**: `/api/tasks`  
**Method**: `POST`  
**Auth Required**: Yes (staff, department_chair, admin roles only)

**Headers**:
```
Authorization: Bearer {jwt-token}
```

**Request Body**:
```json
{
  "title": "Lab Grading",
  "description": "Grade lab submissions for Week 5",
  "task_type": "grading",
  "course_id": "CS101",
  "due_date": "2025-05-15",
  "duration": 120,
  "assignees": [1, 2, 3]  // Array of user IDs
}
```

**Success Response**:
- **Code**: 201 Created
- **Content**: Created task object

**Error Response**:
- **Code**: 403 Forbidden
- **Content**:
```json
{
  "message": "You do not have permission to create tasks"
}
```

### Update Task
Update an existing task.

**URL**: `/api/tasks/:id`  
**Method**: `PUT`  
**Auth Required**: Yes

**Headers**:
```
Authorization: Bearer {jwt-token}
```

**Request Body**:
```json
{
  "title": "Updated Lab Grading",
  "description": "Updated description",
  "task_type": "grading",
  "course_id": "CS101",
  "due_date": "2025-05-16",
  "duration": 150,
  "status": "active",
  "assignees": [1, 4]
}
```

**Success Response**:
- **Code**: 200 OK
- **Content**: Updated task object

**Error Response**:
- **Code**: 403 Forbidden
- **Content**:
```json
{
  "message": "You do not have permission to update this task"
}
```

### Complete Task
Mark a task as completed.

**URL**: `/api/tasks/:id/complete`  
**Method**: `PUT`  
**Auth Required**: Yes

**Headers**:
```
Authorization: Bearer {jwt-token}
```

**Success Response**:
- **Code**: 200 OK
- **Content**:
```json
{
  "message": "Task marked as completed"
}
```

**Error Response**:
- **Code**: 400 Bad Request
- **Content**:
```json
{
  "message": "You are not assigned to this task"
}
```

### Delete Task
Delete a task.

**URL**: `/api/tasks/:id`  
**Method**: `DELETE`  
**Auth Required**: Yes

**Headers**:
```
Authorization: Bearer {jwt-token}
```

**Success Response**:
- **Code**: 200 OK
- **Content**:
```json
{
  "message": "Task deleted successfully"
}
```

**Error Response**:
- **Code**: 403 Forbidden
- **Content**:
```json
{
  "message": "You do not have permission to delete this task"
}
```
```

`backend/middleware/authMiddleware.js`:

```js
const jwt = require('jsonwebtoken');
const { jwtSecret } = require('../config/auth');
const User = require('../models/User');

exports.protect = async (req, res, next) => {
  try {
    // Get token from header
    const token = req.header('Authorization')?.replace('Bearer ', '');

    if (!token) {
      return res.status(401).json({ message: 'Not authorized, no token' });
    }

    // Verify token
    const decoded = jwt.verify(token, jwtSecret);

    // Find user by ID
    const user = await User.findById(decoded.id);
    
    if (!user) {
      return res.status(401).json({ message: 'User not found' });
    }

    // Add user to request object
    req.user = {
      id: user.id,
      bilkentId: user.bilkent_id,
      email: user.email,
      role: user.role
    };

    next();
  } catch (error) {
    console.error('Auth middleware error:', error);
    if (error.name === 'JsonWebTokenError') {
      return res.status(401).json({ message: 'Invalid token' });
    }
    if (error.name === 'TokenExpiredError') {
      return res.status(401).json({ message: 'Token expired' });
    }
    res.status(500).json({ message: 'Server error in auth middleware' });
  }
};

// Role-based authorization middleware
exports.authorize = (...roles) => {
  return (req, res, next) => {
    if (!req.user || !roles.includes(req.user.role)) {
      return res.status(403).json({ message: 'Forbidden: insufficient permissions' });
    }
    next();
  };
};

```

`backend/middleware/validationMiddleware.js`:

```js
// backend/middleware/validationMiddleware.js
const { body, validationResult } = require('express-validator');

/**
 * Custom middleware to validate request based on rules
 * @param {Array} validations - Array of validation rules
 * @returns {Function} - Express middleware function
 */
exports.validate = (validations) => {
  return async (req, res, next) => {
    // Run all validations
    await Promise.all(validations.map(validation => validation.run(req)));

    // Get validation errors
    const errors = validationResult(req);
    
    if (errors.isEmpty()) {
      return next();
    }

    // Format errors for response
    const formattedErrors = {};
    errors.array().forEach(error => {
      formattedErrors[error.path] = error.msg;
    });

    return res.status(400).json({
      message: 'Validation failed',
      errors: formattedErrors
    });
  };
};

// Validation rules for authentication
exports.authValidation = {
  signup: [
    body('bilkentId')
      .exists().withMessage('Bilkent ID is required')
      .isString().withMessage('Bilkent ID must be a string')
      .trim().notEmpty().withMessage('Bilkent ID cannot be empty'),
    
    body('email')
      .exists().withMessage('Email is required')
      .isEmail().withMessage('Must be a valid email address')
      .custom(value => {
        if (!value.endsWith('@bilkent.edu.tr')) {
          throw new Error('Must use a Bilkent email address (@bilkent.edu.tr)');
        }
        return true;
      }),
    
    body('fullName')
      .exists().withMessage('Full name is required')
      .isString().withMessage('Full name must be a string')
      .trim().notEmpty().withMessage('Full name cannot be empty'),
    
    body('password')
      .exists().withMessage('Password is required')
      .isString().withMessage('Password must be a string')
      .isLength({ min: 6 }).withMessage('Password must be at least 6 characters long'),
    
    body('role')
      .optional()
      .isIn(['ta', 'staff', 'department_chair', 'dean', 'admin'])
      .withMessage('Invalid role specified')
  ],
  
  login: [
    body('bilkentId')
      .exists().withMessage('Bilkent ID is required')
      .isString().withMessage('Bilkent ID must be a string')
      .trim().notEmpty().withMessage('Bilkent ID cannot be empty'),
    
    body('password')
      .exists().withMessage('Password is required')
      .isString().withMessage('Password must be a string')
      .notEmpty().withMessage('Password cannot be empty')
  ],
  
  recoverPassword: [
    body('bilkentId')
      .exists().withMessage('Bilkent ID is required')
      .isString().withMessage('Bilkent ID must be a string')
      .trim().notEmpty().withMessage('Bilkent ID cannot be empty')
  ],
  
  resetPassword: [
    body('token')
      .exists().withMessage('Token is required')
      .isString().withMessage('Token must be a string')
      .trim().notEmpty().withMessage('Token cannot be empty'),
    
    body('bilkentId')
      .exists().withMessage('Bilkent ID is required')
      .isString().withMessage('Bilkent ID must be a string')
      .trim().notEmpty().withMessage('Bilkent ID cannot be empty'),
    
    body('newPassword')
      .exists().withMessage('New password is required')
      .isString().withMessage('New password must be a string')
      .isLength({ min: 6 }).withMessage('New password must be at least 6 characters long')
  ]
};

// Parameter normalization middleware
exports.normalizeParams = (req, res, next) => {
  // Normalize common camelCase/snake_case parameter pairs
  const normalizations = [
    { camel: 'bilkentId', snake: 'bilkent_id' },
    { camel: 'fullName', snake: 'full_name' },
    { camel: 'newPassword', snake: 'new_password' }
  ];
  
  normalizations.forEach(({ camel, snake }) => {
    // If both are provided, prefer camelCase (but keep both for backward compatibility)
    if (req.body[camel] !== undefined && req.body[snake] === undefined) {
      req.body[snake] = req.body[camel];
    } else if (req.body[snake] !== undefined && req.body[camel] === undefined) {
      req.body[camel] = req.body[snake];
    }
  });
  
  next();
};
```

`backend/models/Task.js`:

```js
// backend/models/Task.js
const db = require('../config/db');

class Task {
  static async findAll(userId = null, role = null) {
    try {
      // If userId is provided, return tasks assigned to that user (for TAs)
      if (userId && role === 'ta') {
        const [rows] = await db.query(
          `SELECT t.*, u.full_name as assigned_to_name
          FROM tasks t
          JOIN task_assignments ta ON t.id = ta.task_id
          JOIN users u ON u.id = ta.user_id
          WHERE ta.user_id = ?
          ORDER BY t.due_date ASC`,
          [userId]
        );
        return rows;
      }
      
      // If user is staff/instructor, return all tasks created by them
      if (userId && (role === 'staff' || role === 'department_chair')) {
        const [rows] = await db.query(
          `SELECT t.*, u.full_name as assigned_to_name
          FROM tasks t
          LEFT JOIN task_assignments ta ON t.id = ta.task_id
          LEFT JOIN users u ON u.id = ta.user_id
          WHERE t.created_by = ?
          ORDER BY t.due_date ASC`,
          [userId]
        );
        return rows;
      }
      
      // If no userId or admin role, return all tasks
      const [rows] = await db.query(
        `SELECT t.*, u.full_name as assigned_to_name, c.full_name as creator_name
        FROM tasks t
        LEFT JOIN task_assignments ta ON t.id = ta.task_id
        LEFT JOIN users u ON u.id = ta.user_id
        LEFT JOIN users c ON c.id = t.created_by
        ORDER BY t.due_date ASC`
      );
      return rows;
    } catch (error) {
      throw error;
    }
  }

  static async findById(taskId) {
    try {
      const [rows] = await db.query(
        `SELECT t.*, u.full_name as assigned_to_name, c.full_name as creator_name
        FROM tasks t
        LEFT JOIN task_assignments ta ON t.id = ta.task_id
        LEFT JOIN users u ON u.id = ta.user_id
        LEFT JOIN users c ON c.id = t.created_by
        WHERE t.id = ?`,
        [taskId]
      );
      return rows[0];
    } catch (error) {
      throw error;
    }
  }

  static async findUpcoming(userId, limit = 5) {
    try {
      const [rows] = await db.query(
        `SELECT t.*, u.full_name as assigned_to_name
        FROM tasks t
        JOIN task_assignments ta ON t.id = ta.task_id
        JOIN users u ON u.id = ta.user_id
        WHERE ta.user_id = ? AND t.status = 'active' AND t.due_date >= CURDATE()
        ORDER BY t.due_date ASC
        LIMIT ?`,
        [userId, limit]
      );
      return rows;
    } catch (error) {
      throw error;
    }
  }

  static async create(taskData) {
    try {
      const { title, description, task_type, course_id, due_date, duration, created_by } = taskData;
      
      const [result] = await db.query(
        `INSERT INTO tasks (title, description, task_type, course_id, due_date, duration, status, created_by)
        VALUES (?, ?, ?, ?, ?, ?, 'active', ?)`,
        [title, description, task_type, course_id, due_date, duration, created_by]
      );
      
      const taskId = result.insertId;
      
      // If there are assignees, create task assignments
      if (taskData.assignees && taskData.assignees.length > 0) {
        for (const userId of taskData.assignees) {
          await db.query(
            `INSERT INTO task_assignments (task_id, user_id)
            VALUES (?, ?)`,
            [taskId, userId]
          );
        }
      }
      
      return await this.findById(taskId);
    } catch (error) {
      throw error;
    }
  }

  static async update(taskId, taskData) {
    try {
      const { title, description, task_type, course_id, due_date, duration, status } = taskData;
      
      const [result] = await db.query(
        `UPDATE tasks
        SET title = ?, description = ?, task_type = ?, course_id = ?, due_date = ?, duration = ?, status = ?
        WHERE id = ?`,
        [title, description, task_type, course_id, due_date, duration, status, taskId]
      );
      
      // Update task assignments if needed
      if (taskData.assignees && taskData.assignees.length > 0) {
        // Remove existing assignments
        await db.query('DELETE FROM task_assignments WHERE task_id = ?', [taskId]);
        
        // Add new assignments
        for (const userId of taskData.assignees) {
          await db.query(
            `INSERT INTO task_assignments (task_id, user_id)
            VALUES (?, ?)`,
            [taskId, userId]
          );
        }
      }
      
      return result.affectedRows > 0;
    } catch (error) {
      throw error;
    }
  }

  static async complete(taskId, userId) {
    try {
      // Get the task to check if the user is assigned to it
      const task = await this.findById(taskId);
      if (!task) {
        return { success: false, message: 'Task not found' };
      }
      
      // Check if the user is assigned to this task
      const [assignment] = await db.query(
        'SELECT * FROM task_assignments WHERE task_id = ? AND user_id = ?',
        [taskId, userId]
      );
      
      if (assignment.length === 0) {
        return { success: false, message: 'You are not assigned to this task' };
      }
      
      // Update the task status to completed
      const [result] = await db.query(
        'UPDATE tasks SET status = "completed", completed_at = CURRENT_TIMESTAMP WHERE id = ?',
        [taskId]
      );
      
      return { 
        success: result.affectedRows > 0, 
        message: result.affectedRows > 0 ? 'Task marked as completed' : 'Failed to update task'
      };
    } catch (error) {
      throw error;
    }
  }

  static async delete(taskId) {
    try {
      // First delete task assignments
      await db.query('DELETE FROM task_assignments WHERE task_id = ?', [taskId]);
      
      // Then delete the task
      const [result] = await db.query('DELETE FROM tasks WHERE id = ?', [taskId]);
      
      return result.affectedRows > 0;
    } catch (error) {
      throw error;
    }
  }
}

module.exports = Task;

```

`backend/models/User.js`:

```js
// backend/models/User.js
const db = require('../config/db');
const bcrypt = require('bcryptjs');

class User {
  static async findById(id) {
    try {
      const [rows] = await db.query(
        'SELECT id, bilkent_id, email, full_name, role FROM users WHERE id = ?',
        [id]
      );
      return rows[0];
    } catch (error) {
      throw error;
    }
  }

  static async findByBilkentId(bilkentId) {
    try {
      const [rows] = await db.query(
        'SELECT * FROM users WHERE bilkent_id = ?',
        [bilkentId]
      );
      return rows[0];
    } catch (error) {
      throw error;
    }
  }

  static async findByEmail(email) {
    try {
      const [rows] = await db.query(
        'SELECT * FROM users WHERE email = ?',
        [email]
      );
      return rows[0];
    } catch (error) {
      throw error;
    }
  }

  static async create(userData) {
    try {
      const hashedPassword = await bcrypt.hash(userData.password, 10);
      const [result] = await db.query(
        'INSERT INTO users (bilkent_id, email, password, full_name, role) VALUES (?, ?, ?, ?, ?)',
        [userData.bilkent_id, userData.email, hashedPassword, userData.full_name, userData.role]
      );
      return { 
        id: result.insertId,
        bilkent_id: userData.bilkent_id,
        email: userData.email,
        full_name: userData.full_name,
        role: userData.role
      };
    } catch (error) {
      throw error;
    }
  }

  static async updatePassword(bilkentId, newPassword) {
    try {
      const hashedPassword = await bcrypt.hash(newPassword, 10);
      const [result] = await db.query(
        'UPDATE users SET password = ? WHERE bilkent_id = ?',
        [hashedPassword, bilkentId]
      );
      return result.affectedRows > 0;
    } catch (error) {
      throw error;
    }
  }

  static async verifyPassword(plainPassword, hashedPassword) {
    return await bcrypt.compare(plainPassword, hashedPassword);
  }
}

module.exports = User;
```

`backend/package.json`:

```json
{
  "name": "ta-management-system-backend",
  "version": "1.0.0",
  "description": "Backend for TA Management System",
  "main": "server.js",
  "scripts": {
    "start": "node server.js",
    "dev": "nodemon server.js",
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [
    "ta-management",
    "express",
    "mysql"
  ],
  "author": "",
  "license": "ISC",
  "dependencies": {
    "bcryptjs": "^2.4.3",
    "cors": "^2.8.5",
    "dotenv": "^16.3.1",
    "express": "^4.18.2",
    "express-validator": "^7.0.1",
    "jsonwebtoken": "^9.0.2",
    "mysql2": "^3.6.1",
    "nodemailer": "^6.9.5"
  },
  "devDependencies": {
    "nodemon": "^3.1.10"
  }
}
```

`backend/routes/authRoutes.js`:

```js
// backend/routes/authRoutes.js
const express = require('express');
const router = express.Router();
const { 
  login, 
  recoverPassword, 
  resetPassword, 
  logout, 
  signup 
} = require('../controllers/authController');
const { protect } = require('../middleware/authMiddleware');
const { 
  validate, 
  authValidation, 
  normalizeParams 
} = require('../middleware/validationMiddleware');

// Apply parameter normalization middleware to all routes
router.use(normalizeParams);

/**
 * @route POST /api/auth/login
 * @desc Authenticate user & get token
 * @access Public
 */
router.post('/login', validate(authValidation.login), login);

/**
 * @route POST /api/auth/recover-password
 * @desc Send password recovery email
 * @access Public
 */
router.post('/recover-password', validate(authValidation.recoverPassword), recoverPassword);

/**
 * @route POST /api/auth/reset-password
 * @desc Reset user password
 * @access Public
 */
router.post('/reset-password', validate(authValidation.resetPassword), resetPassword);

/**
 * @route POST /api/auth/logout
 * @desc Logout user (client-side implementation)
 * @access Private
 */
router.post('/logout', protect, logout);

/**
 * @route POST /api/auth/signup
 * @desc Register a new user
 * @access Public
 */
router.post('/signup', validate(authValidation.signup), signup);

module.exports = router;
```

`backend/routes/taskRoutes.js`:

```js
// backend/routes/taskRoutes.js
const express = require('express');
const router = express.Router();
const { 
  getAllTasks, 
  getTaskById, 
  getUpcomingTasks,
  createTask, 
  updateTask, 
  completeTask,
  deleteTask
} = require('../controllers/taskController');
const { protect, authorize } = require('../middleware/authMiddleware');

// All routes are protected and require authentication
router.use(protect);

// Get upcoming tasks
router.get('/upcoming', getUpcomingTasks);

// Get all tasks (filtered by user role & id)
router.get('/', getAllTasks);

// Get a specific task
router.get('/:id', getTaskById);

// Create a new task - only instructors, department chair, and admin can create tasks
router.post('/', authorize('staff', 'department_chair', 'admin'), createTask);

// Update a task
router.put('/:id', updateTask);

// Mark a task as completed
router.put('/:id/complete', completeTask);

// Delete a task
router.delete('/:id', deleteTask);

module.exports = router;

```

`backend/server.js`:

```js
// backend/server.js
require('dotenv').config();
const express = require('express');
const cors = require('cors');
const app = express();
const authRoutes = require('./routes/authRoutes');
const taskRoutes = require('./routes/taskRoutes');
const db = require('./config/db');

// Middleware
app.use(cors());
app.use(express.json());

// Test DB Connection
db.getConnection()
  .then(connection => {
    console.log('Database connection established');
    connection.release();
  })
  .catch(err => {
    console.error('Database connection failed:', err);
  });

// Routes
app.use('/api/auth', authRoutes);
app.use('/api/tasks', taskRoutes); 

// Error handling middleware
app.use((err, req, res, next) => {
  console.error(err.stack);
  res.status(500).send({ message: 'Something went wrong!' });
});

const PORT = process.env.PORT || 5001;
app.listen(PORT, () => {
  console.log(`Server running on port ${PORT}`);
});

```
